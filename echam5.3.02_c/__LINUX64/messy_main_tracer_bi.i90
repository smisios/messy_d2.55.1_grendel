# 1 "../../messy/bmil/messy_main_tracer_bi.f90"
# 1 "../../messy/bmil/messy_main_ppd_bi.inc" 1 
! -*- f90 -*-
# 11


! ----------------------------------------------------------------------
! SETTINGS FOR VARIOUS BASEMODELS
! ----------------------------------------------------------------------
! SO FAR FOR ALL MESSy BASEMODES




! ORDER: h,v,[n],h (TRRANK=3)  OR h,v,h,[n] (TRRANK=4)




! ORDER: h,h,[n],v (TRRANK=3)  OR h,h,v,[n] (TRRANK=4)
# 29


# 33




! ----------------------------------------------------------------------
! GENERIC SETTINGS
! ----------------------------------------------------------------------

! ----------------------------------------------------------------------
! ORDER: h,v,[n],h OR h,v,h,[n]

! ----------------------------------------------------------------------

! op_pj_20170228: macros required for TTRANK=3 (messy_main_tracer)













! classical RI to pass one `jrow` to SMCL:





! only ONEMIS, BIOBURN, GMXE, VEG:






! op_pj_20170228: macros required for TTRANK=4 (messy_main_tracer)
# 97

!
! ----------------------------------------------------------------------

! ----------------------------------------------------------------------

! ----------------------------------------------------------------------
! ORDER: h,h,[n],v OR h,h,v,[n]
# 160

! ----------------------------------------------------------------------
# 2 "../../messy/bmil/messy_main_tracer_bi.f90" 2 

! **********************************************************************+
MODULE messy_main_tracer_bi
! **********************************************************************+

  USE messy_main_tracer_mem_bi
  USE messy_main_blather_bi,      ONLY: start_message_bi, end_message_bi
  USE messy_main_constants_mem,   ONLY: FLAGGED_BAD
  USE messy_main_tracer_tools_bi, ONLY: tracer_halt
# 14

  USE messy_main_tracer

  IMPLICIT NONE
  PRIVATE

  TYPE T_INIPVAR_IO
     CHARACTER(LEN=20)           :: basemodel = '' ! basemodel name
     CHARACTER(LEN=STRLEN_FNAME) :: pvar      = '' ! name of prog. var.
     CHARACTER(LEN=STRLEN_FNAME) :: inp       = '' ! name of input field
     INTEGER                     :: switch    = 0  ! switch for conversion
  END TYPE T_INIPVAR_IO
!
  INTEGER, PARAMETER :: N_INI_MAX = 20
!
  TYPE(T_INIPVAR_IO), DIMENSION(N_INI_MAX), SAVE :: ini_pvar

! GLOBAL NAMELIST SWITCHES (CPL)
  LOGICAL,  SAVE :: l_tracer_init = .TRUE.
  LOGICAL,  SAVE :: l_tracer_initfromrestart = .FALSE.
! only for LG->GP conversion (ATTILA)
  LOGICAL,  SAVE :: l_conv_lg2gp      = .TRUE.        ! do it?
  INTEGER,  SAVE :: i_conv_lg2gp_mode = 2             ! LG2GP_AVE
  REAL(DP), SAVE :: r_conv_lg2gp_fill = FLAGGED_BAD   ! fill with?
  LOGICAL,  SAVE :: l_conv_lg2gp_mc   = .FALSE.       ! mass conservarions?
! only for LG->GP conversion (CLaMS)
  LOGICAL,  SAVE :: l_conv_cl2gp      = .TRUE.        ! do it?
  INTEGER,  SAVE :: i_conv_cl2gp_mode = 2             ! CL2GP_AVE
  REAL(DP), SAVE :: r_conv_cl2gp_fill = FLAGGED_BAD   ! fill with?

# 47

! PUBLIC SUBROUTINES CALLED FROM BM(I)L
! 1/MESSy SPECIFIC
  PUBLIC :: main_tracer_setup         ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_initialize    ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_new_tracer    ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_init_memory   ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_init_coupling ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_init_tracer   ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_global_start  ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_beforeadv     ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_afteradv      ! CALLED FROM messy_main_control_e5/c4
! SPECIAL: CALLED BEFORE OUTPUT
  PUBLIC :: main_tracer_write_output  ! CALLED FROM messy_main_control_e5/c4
!!#D attila +
!PRIVATE :: tracer_out_conv_lg2gp    ! CONVERT LG TRACERS TO GP FOR OUTPUT
!!#D attila -
!!#D clams +
!PRIVATE :: tracer_out_conv_cl2gp    ! CONVERT CL TRACERS TO GP FOR OUTPUT
!!#D clams -
!
  PUBLIC :: main_tracer_local_start   ! CALLED FROM messy_main_control_e5/c4
# 73

  PUBLIC :: main_tracer_global_end    ! CALLED FROM messy_main_control_e5/c4
  PUBLIC :: main_tracer_free_memory   ! CALLED FROM messy_main_control_e5/c4
!
!PRIVATE :: setup_tracer_set_gp
!PRIVATE :: setup_tracer_set_lg
!PRIVATE :: setup_tracer_set_om
!PRIVATE :: setup_tracer_set_ec
!PRIVATE :: setup_tracer_set_cl
!
!PRIVATE :: main_tracer_read_nml_cpl

! SUBMODEL SMIL
!
! CONVERSION ROUTINES (FAMILIES) TO BE USED IN SUBMODEL SMIL
  PUBLIC :: main_tracer_fconv_loc     ! CONVERT FAMILIES <-> TRACERS
  PUBLIC :: main_tracer_fconv_glb     ! CONVERT FAMILIES <-> TRACERS
!
!PRIVATE :: tracer_init ! initialise tracers
!PRIVATE :: init_pvar   ! initialise prognostic variables of basemodel
# 98


CONTAINS

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_setup

! TRACER MODULE ROUTINE (BASEMODEL INTERFACE)
!
! INITIALIZATION OF GLOBAL VARIABLES FROM NAMELIST
! IN PARALLEL ENVIRONMENT
!
! Author: Patrick Joeckel, MPICH, July 2002

! NOTES:
! - n_trcr_block must be read before initialize for COSMO

    USE messy_main_mpi_bi,           ONLY: p_parallel_io, p_io, p_bcast
    USE messy_main_blather_bi,       ONLY: error_bi
    USE messy_main_tools,            ONLY: find_next_free_unit

    IMPLICIT NONE

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_setup'
    INTEGER                     :: iou    ! I/O unit
    INTEGER                     :: status ! error status
    INTEGER                     :: i

! select basemodel dependent rank of tracer index in internal memory
    TRRANK = 3

    IF (p_parallel_io) THEN
       iou = find_next_free_unit(100,200)
       CALL main_tracer_read_nml_ctrl(status, iou)
       IF (status /= 0) CALL error_bi( &
            'main_tracer_read_nml_ctrl reported an error', substr)
    END IF
    CALL p_bcast(l_family, p_io)
    CALL p_bcast(l_pdef, p_io)
    DO i=1, NMAXTRACPROP
       CALL p_bcast(TPROP(i)%trset, p_io)
       CALL p_bcast(TPROP(i)%trlist, p_io)
       CALL p_bcast(TPROP(i)%caskname, p_io)
       CALL p_bcast(TPROP(i)%cont, p_io)
    END DO

    IF (p_parallel_io) THEN
       iou = find_next_free_unit(100,200)
       CALL main_tracer_read_nml_cpl(status, iou)
       IF (status /= 0) CALL error_bi( &
            'main_tracer_read_nml_cpl reported an error', substr)
    END IF
    CALL p_bcast(l_tracer_init, p_io)
    CALL p_bcast(l_tracer_initfromrestart, p_io)
    CALL p_bcast(l_conv_lg2gp, p_io)
    CALL p_bcast(i_conv_lg2gp_mode, p_io)
    CALL p_bcast(r_conv_lg2gp_fill, p_io)
    CALL p_bcast(l_conv_lg2gp_mc, p_io)
    CALL p_bcast(n_trcr_block, p_io)
!
    CALL p_bcast(l_conv_cl2gp, p_io)
    CALL p_bcast(i_conv_cl2gp_mode, p_io)
    CALL p_bcast(r_conv_cl2gp_fill, p_io)

    DO i=1, N_INI_MAX
       CALL p_bcast(ini_pvar(i)%basemodel, p_io)
       CALL p_bcast(ini_pvar(i)%pvar,      p_io)
       CALL p_bcast(ini_pvar(i)%inp,       p_io)
       CALL p_bcast(ini_pvar(i)%switch,    p_io)
    END DO

  END SUBROUTINE main_tracer_setup
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_initialize

! keep PDEF and FAMIILY CALLs in initialize because of timer_event_init

    USE messy_main_tracer_family_bi, ONLY: main_tracer_family_initialize
    USE messy_main_tracer_pdef_bi,   ONLY: main_tracer_pdef_initialize

    IMPLICIT NONE

    IF (l_family) CALL main_tracer_family_initialize

    IF (l_pdef) CALL main_tracer_pdef_initialize

  END SUBROUTINE main_tracer_initialize
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_new_tracer(flag)

    USE messy_main_mpi_bi,           ONLY: p_parallel_io
    USE messy_main_blather_bi,       ONLY: error_bi
    USE messy_main_tracer_family_bi, ONLY: main_tracer_family_new_tracer
    USE messy_main_channel_bi,       ONLY: REPR_UNDEF, GP_3D_MID &
                                         , GP_3D_MPIOM
!!#D clams +
    USE messy_main_channel_bi,       ONLY: REPR_LG_CLAMS
!!#D clams -
# 206


    IMPLICIT NONE

! I/O
    INTEGER, INTENT(IN) :: flag

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_new_tracer'
    INTEGER                     :: status
# 221


! INIT SWITCH

    L_GP = (GP_3D_MID  /= REPR_UNDEF)
!!#D clams +
    L_CL = (REPR_LG_CLAMS /= REPR_UNDEF)
!!#D clams -

    L_LG   = (NGCELL > 0)

    L_OM   = (GP_3D_MPIOM /= REPR_UNDEF)

    SELECT CASE(flag)
    CASE(1)
!
       CALL start_message_bi(modstr,'SETUP TRACER SETS',substr)
!

       CALL new_tracer_set(status, GPTRSTR, L_GP)
       CALL tracer_halt(substr, status)
# 256

!
! added for clams tracer development
       CALL new_tracer_set(status, CLTRSTR, L_CL)
       CALL tracer_halt(substr, status)
!
       CALL new_tracer_set(status, LGTRSTR, L_LG)
       CALL tracer_halt(substr, status)
!
       CALL new_tracer_set(status, OMTRSTR, L_OM)
       CALL tracer_halt(substr, status)
!
       CALL end_message_bi(modstr,'SETUP TRACER SETS',substr)
!
# 282

!
    CASE (2)
!
       IF (l_family) CALL main_tracer_family_new_tracer
!
# 311

!
    CASE(3)
!

       CALL start_message_bi(modstr,'OVERWRITE TRACER PROPERTIES',substr)
       CALL set_tracer_properties(status, lprint=p_parallel_io)
       CALL tracer_halt(substr, status)
       CALL end_message_bi(modstr,'OVERWRITE TRACER PROPERTIES',substr)
!
       CALL start_message_bi(modstr,'SHOW TRACER SETS',substr)
!
       IF (p_parallel_io) CALL print_tracer_set
!
       CALL end_message_bi(modstr,'SHOW TRACER SETS',substr)

!
    CASE DEFAULT
!
       CALL error_bi( 'UNKNOWN FLAG !', substr)
!
    END SELECT

  END SUBROUTINE main_tracer_new_tracer
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_init_memory(flag)

    USE messy_main_mpi_bi,           ONLY: p_parallel_io
    USE messy_main_blather_bi,       ONLY: error_bi
    USE messy_main_tools,            ONLY: remap_bounds
    USE messy_main_channel_error_bi, ONLY: channel_halt
    USE messy_main_channel_bi,       ONLY: GP_3D_MID

    USE messy_main_channel_bi,       ONLY: LG_ATTILA, GP_3D_MPIOM

!!#D clams +
    USE messy_main_channel_bi,       ONLY: REPR_LG_CLAMS
!!#D clams -
    USE messy_main_channel_tracer,   ONLY: create_tracer_channels
    USE messy_main_tracer_family_bi, ONLY: main_tracer_family_init_mem
    USE messy_main_tracer_pdef_bi,   ONLY: main_tracer_pdef_init_mem
# 356

# 360


    IMPLICIT NONE

! I/O
    INTEGER, INTENT(IN)           :: flag

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_init_memory'
    INTEGER :: status
# 372


    SELECT CASE(flag)
    CASE (1) !==============================================================
!
       CALL start_message_bi(modstr,'SETUP TRACER MEMORY',substr)

       CALL setup_tracer_set_gp

! INITALIZE POINTER (messy_main_tracer_mem_bi.90)
       IF (L_GP) THEN
          xt    => pxt(:,:,:,:,1)
          xtm1  => pxtm1(:,:,:,:,1)
          xtte  => pxtte(:,:,:,:,1)

          xtf   => pxtf(:,:,:,:,1)
# 394

       ENDIF

# 409



       IF ( l_conv_cl2gp .AND. (.NOT. L_CL ) ) THEN
          IF (p_parallel_io) THEN
             WRITE(*,*) ' L_CONV_CL2GP = T in namelist will be ignored,'
             WRITE(*,*) ' since CLAMS is NOT running!'
          END IF
          l_conv_cl2gp = .FALSE.
       END IF
       CALL setup_tracer_set_cl

! initalize CLaMS TRACER pointer (messy_main_tracer_mem_bi.90)
       if (l_cl) then
          xt_c    => pxt_c(:,:,:,:,1)
          xtm1_c  => pxt_c(:,:,:,:,1)  !!! same as xt for CLamS !!!
          xtte_c  => pxtte_c(:,:,:,:,1)
          IF (l_conv_cl2gp) xt_clgp => pxt_clgp(:,:,:,:,1)
       endif

! ------------

       IF ( l_conv_lg2gp .AND. (.NOT. L_LG ) ) THEN
          IF (p_parallel_io) THEN
             WRITE(*,*) ' L_CONV_LG2GP = T in namelist will be ignored,'
             WRITE(*,*) ' since no LAGRANGIAN scheme is running!'
          END IF
          l_conv_lg2gp = .FALSE.
       END IF

       CALL setup_tracer_set_lg

! INITALIZE POINTER (messy_main_tracer_mem_bi.90)
       IF (L_LG) THEN
          xt_a => pxt_a(:,:,:,:,1)
          xtm1_a => pxtm1_a(:,:,:,:,1)
          xtte_a => pxtte_a(:,:,:,:,1)
          xtf_a  => pxtf_a(:,:,:,:,1)
!
          IF (l_conv_lg2gp) xt_lggp => pxt_lggp(:,:,:,:,1)
       END IF
!

       CALL setup_tracer_set_om
! INITALIZE POINTER (messy_main_tracer_mem_bi.90)
       IF (L_OM) THEN
          xt_om => pxt_om(:,:,:,:,1)
       END IF

!
       CALL end_message_bi(modstr,'SETUP TRACER MEMORY',substr)
!
    CASE (2) !==============================================================
!
       CALL start_message_bi(modstr,'TRACER MEMORY CHANNEL COUPLING',substr)
!
! COUPLE TRACER MEMORY TO CHANNELS

       CALL create_tracer_channels(status, GPTRSTR, gp_channel, GP_3D_MID)
       CALL channel_halt(substr, status)
# 477

!

!!#D clams +
! creating CLaMS tracer channels
       CALL create_tracer_channels(status, &
           CLTRSTR,   cl_channel  , REPR_LG_CLAMS)
       CALL channel_halt(substr, status)
       IF (l_conv_cl2gp) THEN
          CALL create_tracer_channels(status, &
               CLGPTRSTR, clgp_channel, GP_3D_MID)
          CALL channel_halt(substr, status)
       END IF
!!#D clams -

       CALL create_tracer_channels(status, LGTRSTR, lg_channel, LG_ATTILA)
       CALL channel_halt(substr, status)
!
       IF (l_conv_lg2gp) THEN
          CALL create_tracer_channels(status, LGGPTRSTR, &
               lggp_channel, GP_3D_MID)
          CALL channel_halt(substr, status)
       END IF
!
       CALL create_tracer_channels(status, OMTRSTR, om_channel, GP_3D_MPIOM)
       CALL channel_halt(substr, status)

!

       IF (l_pdef) CALL main_tracer_pdef_init_mem
!
! setting meta information of family-members to fraction
! (for advection initialization)
       IF (l_family) CALL main_tracer_family_init_mem
!

!!$#if defined(ICON)
!!$       !
!!$       CALL map_tracer_memory_icon(2)
!!$       !
!!$#endif
!
       CALL end_message_bi(modstr,'TRACER MEMORY CHANNEL COUPLING',substr)
!
# 595

!
    CASE DEFAULT
!
       CALL error_bi('UNKNOWN FLAG !', substr)
!
    END SELECT

  END SUBROUTINE main_tracer_init_memory
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_init_coupling(flag)

    USE messy_main_tracer_family_bi, ONLY: main_tracer_family_init_cpl
    USE messy_main_tracer_pdef_bi,   ONLY: main_tracer_pdef_init_cpl
    USE messy_main_blather_bi,       ONLY: error_bi

    IMPLICIT NONE

    INTEGER, INTENT(IN) :: flag

    CHARACTER(LEN=*), PARAMETER :: substr='main_tracer_init_coupling'

    SELECT CASE(flag)

    CASE (1)
       IF (l_family) CALL main_tracer_family_init_cpl

       IF (l_pdef) CALL main_tracer_pdef_init_cpl
# 628

    CASE DEFAULT
       CALL error_bi('UNKNOWN FLAG ! ',substr)
    END SELECT

  END SUBROUTINE main_tracer_init_coupling
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_init_tracer(flag)

    USE messy_main_mpi_bi,           ONLY: p_parallel_io
    USE messy_main_blather_bi,       ONLY: error_bi, info_bi
    USE messy_main_data_bi,          ONLY: eps
    USE messy_main_timer,            ONLY: lresume
    USE messy_main_channel_error_bi, ONLY: channel_halt
    USE messy_main_tracer,           ONLY: NSETID, STRLEN_TRSET &
                                         , get_tracer_set       &
                                         , I_MMD_INIT, ON
    USE messy_main_channel,          ONLY: get_channel_object_info
# 650


    IMPLICIT NONE

    INTRINSIC :: ASSOCIATED, NULL, TRIM

! I/O
    INTEGER, INTENT(IN) :: flag

! LOCAL
    CHARACTER(LEN=*), PARAMETER  :: substr = 'main_tracer_init_tracer'
    INTEGER                      :: status
    TYPE(t_trinfo_list), POINTER :: til => NULL()
    CHARACTER(LEN=STRLEN_TRSET)  :: setname = ''
    REAL(DP), DIMENSION(:,:,:,:,:), POINTER :: zpxt   => NULL()
    REAL(DP), DIMENSION(:,:,:,:,:), POINTER :: zpxtm1 => NULL()
    LOGICAL :: linit, linit_m1
    LOGICAL :: l_init
    LOGICAL :: linit_mmd
    INTEGER :: i, ntrac
    LOGICAL :: l_enabled
# 673

    CHARACTER(LEN=STRLEN_TRSET) :: sname = ''

    SELECT CASE(flag)
    CASE(1)
!
       CALL start_message_bi(modstr,'CHECK TRACER INIT FROM RESTART',substr)
!
    CASE(4)
!
       CALL start_message_bi(modstr,'INITIALISE TRACER VIA TRACER_INIT',substr)
       IF (l_tracer_init) THEN
          CALL tracer_init
       ELSE
          CALL info_bi(' ... skipped (l_tracer_init=F in CPL)', substr)
       END IF
       CALL end_message_bi(modstr,'INITIALISE TRACER VIA TRACER_INIT',substr)
       RETURN
!
    CASE(2)
       CALL start_message_bi(modstr,'CHECK TRACER INIT BY TRACER_INIT',substr)
!
    CASE(3)
!
       CALL start_message_bi(modstr,'DIAGNOSE TRACER INITIALIZATION',substr)
!
    CASE DEFAULT
!
       CALL error_bi('UNKNOWN FLAG !', substr)
!
    END SELECT

    set_loop: DO i=1, NSETID
!
       CALL get_tracer_set(status, i, setname=setname &
            , trlist=til, xt=zpxt, xtm1=zpxtm1 &
            , ntrac=ntrac, l_init=l_init       &
            , l_enable=l_enabled)
       CALL tracer_halt(substr, status)
       IF (p_parallel_io) THEN
          WRITE(*,*) '*** TRACER SET '//TRIM(setname)//' *** enabled = '&
               , l_enabled
       END IF

       IF (.NOT. l_init)    CYCLE
       IF (.NOT. l_enabled) CYCLE
       IF (ntrac <= 0)      CYCLE

       tracer_loop: DO
          IF (.NOT.ASSOCIATED(til)) EXIT

          SELECT CASE(flag)
          CASE(1)
!
! CHECK IF TRACER HAS BEEN INITIALIZED VIA RESTART
! -> CHANNEL OBJECTS FOR X and X_m1 have restart_read = .true.
# 732

             sname = modstr//'_'//TRIM(setname)

             CALL get_channel_object_info(status, TRIM(sname)           &
                  , TRIM(til%info%ident%fullname), lrestart_read=linit  &
# 739

                  )
             CALL channel_halt(substr, status)

             IF (ASSOCIATED(zpxtm1)) THEN
                CALL get_channel_object_info(status, TRIM(sname)//'_m1' &
                     , TRIM(til%info%ident%fullname), lrestart_read=linit_m1 &
# 748

                     )
                CALL channel_halt(substr, status)
             ELSE
                linit_m1 = .TRUE.
             END IF

! CHECK IF gridpoint tracer was initialised by MMD
             linit_mmd = til%info%meta%cask_i(I_MMD_INIT) == ON
! ... or by BASEMODEL
             til%info%meta%linit = til%info%meta%linit .OR. &
                  (linit .AND. linit_m1) .OR. linit_mmd

             IF (til%info%meta%linit) THEN
                IF (p_parallel_io) THEN

                   WRITE(*,*) 'TRACER '//TRIM(til%info%ident%fullname)//' (', &
                        til%info%ident%idx,                  &
                        ') WAS INITIALIZED FROM RESTART-FILE!'
# 777

                END IF
! CHECK FOR lforce_init (FORCE TRACER_INIT OR vini)
                IF (til%info%meta%cask_i(I_force_init)==ON) THEN
                   IF (p_parallel_io) THEN
                      WRITE(*,*) ' force_init -> ', &
                           'RESTART INITIALIZATION WILL BE IGNORED'
                   END IF
                   til%info%meta%linit = .false.
                END IF
             ELSE
                IF (p_parallel_io) THEN
                   WRITE(*,*) 'TRACER '//TRIM(til%info%ident%fullname)//' (', &
                        til%info%ident%idx,                  &
                        ') WAS NOT INITIALIZED FROM RESTART-FILE ...'
                END IF
             END IF
!
          CASE(2)
!
! CHECK IF TRACER HAS BEEN INITIALIZED IN SOME WAY
             IF (til%info%meta%linit) THEN
                IF (p_parallel_io) THEN
                   WRITE(*,*) 'TRACER '//TRIM(til%info%ident%fullname)//' (', &
                        til%info%ident%idx,                  &
                        ') ALREADY INITIALIZED ... !'
                END IF
             ELSE
                IF (p_parallel_io) THEN
                   WRITE(*,*) 'TRACER '//TRIM(til%info%ident%fullname)//' (', &
                        til%info%ident%idx,                  &
                        ') WILL BE SET TO ', til%info%meta%cask_R(R_vini)
                END IF

                zpxt( :,:,til%info%ident%idx,:,:) = &
                     til%info%meta%cask_R(R_vini)

                IF (ASSOCIATED(zpxtm1)) THEN
                   IF (lresume) &
                        zpxtm1(:,:,til%info%ident%idx,:,:) = &
                        (1._DP -eps) &
                        * zpxt(:,:,til%info%ident%idx,:,:)
                END IF

                til%info%meta%linit = .TRUE.
             END IF
!
          CASE (3)
!
! NOTHING TO DO
          END SELECT

          til => til%next
       END DO tracer_loop
!
    END DO set_loop


    SELECT CASE(flag)
    CASE(1)
!
       CALL end_message_bi(modstr,'CHECK TRACER INIT FROM RESTART',substr)
!
    CASE(2)
!
       CALL end_message_bi(modstr,'CHECK TRACER INIT BY TRACER_INIT',substr)
!
    CASE(3)
!
! --- DIAGNOSTIC OUTPUT
!
       IF (p_parallel_io) CALL print_tracer_set_val
!
       CALL end_message_bi(modstr,'DIAGNOSE TRACER INITIALIZATION',substr)
!
    CASE DEFAULT
!
       CALL error_bi('UNKNOWN FLAG !', substr)
!
    END SELECT

  END SUBROUTINE main_tracer_init_tracer
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_global_start

    USE messy_main_tracer_pdef_bi,     ONLY: main_tracer_pdef_global_start

    IMPLICIT NONE

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_global_start'


! LAGRANGIAN TRACERS ATTILA
    IF (L_LG) THEN
       qxt_a    => xt_a(:,1,:,1)
       qxtte_a  => xtte_a(:,1,:,1)
       qxtm1_a  => xtm1_a(:,1,:,1)
       qxtf_a   => xtf_a(:,1,:,1)
    ENDIF

! LAGRANGIAN TRACERS CLaMS
    IF (L_CL) THEN
       qxt_c    => xt_c(:,1,:,1)
       qxtte_c  => xtte_c(:,1,:,1)
       qxtm1_c  => xtm1_c(:,1,:,1)
    ENDIF

!
       IF (l_pdef) CALL main_tracer_pdef_global_start

# 893


  END SUBROUTINE main_tracer_global_start
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_beforeadv

    USE messy_main_tracer_family_bi,   ONLY: main_tracer_family_beforeadv

    IMPLICIT NONE

! TYPE-1: t2f
! TYPE-2: summation (GPTRSTR)
       IF (l_family) CALL main_tracer_family_beforeadv

  END SUBROUTINE main_tracer_beforeadv
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_afteradv

    USE messy_main_tracer_family_bi, ONLY: main_tracer_family_afteradv

    IMPLICIT NONE

    IF (l_family) CALL main_tracer_family_afteradv

  END SUBROUTINE main_tracer_afteradv
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_local_start

    USE messy_main_grid_def_mem_bi,  ONLY: jrow
# 930


    IMPLICIT NONE

! SET POINTERS FOR WITHIN LOCAL LOOP

! GRIDPOINT TRACERS
    IF (L_GP) THEN
       qxt    => xt(:,:,:,jrow)
       qxtte  => xtte(:,:,:,jrow)
       qxtm1  => xtm1(:,:,:,jrow)

       qxtf   => xtf(:,:,:,jrow)

# 948

    END IF


    IF (L_LG) THEN
       IF (l_conv_lg2gp) qxt_lggp => xt_lggp(:,:,:,jrow)
    END IF

    IF (L_CL) THEN
       IF (l_conv_cl2gp) qxt_clgp => xt_clgp(:,:,:,jrow)
    END IF


  END SUBROUTINE main_tracer_local_start
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_global_end


    USE messy_main_grid_def_bi,      ONLY: grmass=>grmassdry
# 971

    USE messy_main_tracer_pdef_bi,   ONLY: main_tracer_pdef_global_end
    USE messy_main_tracer_pdef,      ONLY: tracpdef_airmass

!!#D attila +
    USE messy_attila_mem,            ONLY: AMCELL
!!#D attila -
!!#D mpiom +
    USE messy_mpiom_e5,              ONLY: omvol
!!#D mpiom -


    IMPLICIT NONE

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_global_end'

# 991


    IF (l_pdef) THEN

!
       CALL tracpdef_airmass(GPTRSTR, grmass)
!

!!#D attila +
       IF (L_LG) CALL tracpdef_airmass(LGTRSTR, AMCELL)
       IF (l_conv_lg2gp) CALL tracpdef_airmass(LGGPTRSTR, grmass)
!!#D attila -
!
!!#D mpiom +
       IF (L_OM) CALL tracpdef_airmass(OMTRSTR, omvol)
!!#D mpiom -

!
       CALL main_tracer_pdef_global_end
!
# 1025

    END IF

  END SUBROUTINE main_tracer_global_end
! -------------------------------------------------------------------

! -------------------------------------------------------------------
# 1056

! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_free_memory

    USE messy_main_tracer_pdef_bi,   ONLY: main_tracer_pdef_free_mem
    USE messy_main_tracer_family_bi, ONLY: main_tracer_family_free_mem
# 1066


    IMPLICIT NONE

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_free_memory'
    INTEGER :: status
# 1075


    CALL start_message_bi(modstr,'FREE TRACER MEMORY',substr)


    CALL clean_tracer_set(status, GPTRSTR)
    CALL tracer_halt(substr, status)
# 1107



! CLaMS tracer set added, cleaning here
    CALL clean_tracer_set(status, CLTRSTR)
    CALL tracer_halt(substr, status)
    IF (l_conv_cl2gp) THEN
       CALL clean_tracer_set(status, CLGPTRSTR)
       CALL tracer_halt(substr, status)
    END IF



    CALL clean_tracer_set(status, LGTRSTR)
    CALL tracer_halt(substr, status)
!
    IF (l_conv_lg2gp) THEN
       CALL clean_tracer_set(status, LGGPTRSTR)
       CALL tracer_halt(substr, status)
    END IF


    IF (l_pdef) CALL main_tracer_pdef_free_mem

    IF (l_family) CALL main_tracer_family_free_mem

# 1143


    CALL end_message_bi(modstr,'FREE TRACER MEMORY',substr)

  END SUBROUTINE main_tracer_free_memory
! -------------------------------------------------------------------

! ------------------------------------------------------------------
  SUBROUTINE TRACER_INIT



! INITIALIZES TRACER FIELDS FROM netCDF FILES
! (USING IMPORT_GRID) AS DEFINED IN NAMELIST FILE tracer.nml'
!
! Author: Patrick Joeckel, MPICH, Mainz, November 2002
!         Patrick Joeckel, MPICH, Mainz, March    2004
!         Patrick Joeckel, DLR-IPA, Oberpfaffenhofen, December 2009
!         Astrid  Kerkweg, UNI-Mz, Mainz, August 2013

    USE messy_main_mpi_bi,           ONLY: p_parallel_io, p_io, p_bcast  &
                                         , dcg, scatter_gp               &
                                         , p_pe, p_nprocs, p_all_comm    &
                                         , p_send, p_recv
    USE messy_main_blather_bi,      ONLY: start_message_bi, end_message_bi &
                                        , error_bi, warning_bi
    USE messy_main_data_bi,          ONLY: eps
# 1172

    USE messy_main_grid_def_mem_bi,  ONLY: nlev, nproma, ngpblks        &

                                         , nlon, ngl                    &

                                         , BASEGRID_ID
    USE messy_main_import_grid,      ONLY: RG_CTRL, RG_NML              &
                                         , NML_NEXT   &
                                         , RG_SCAN, RG_STATUS           &
                                         , RGSTAT_STOP, READ_CONTROL
    USE messy_main_import_grid_par,  ONLY: RGSTAT_NULL, INIT_PIMPGRID   &
                                         , INIT_PARALLEL, pe_list       &
                                         , nproc_work
    USE messy_main_grid,             ONLY: t_geohybgrid, INIT_GEOHYBGRID &
                                         , grid_error
    USE messy_main_grid,             ONLY: LOCATE_GEOHYBGRID           &
                                         , INIT_GEOHYBGRID
    USE messy_main_grid_netcdf,      ONLY: RGMSG, ERRMSG, RGMLVL, RGMLW     &
                                         , RGMLWC, INIT_NCVAR &
                                         , t_ncvar
    USE messy_main_grid_tools,       ONLY: RGTOOL_CONVERT
    USE messy_main_grid_trafo_nrgd,  ONLY: REGRID_CONTROL
    USE messy_main_channel_error_bi, ONLY: CHANNEL_HALT
    USE messy_main_channel_bi,       ONLY: main_channel_read_restart
    USE messy_main_channel_mem,      ONLY: dom_curid
    USE messy_main_channel_repr,     ONLY: repr_def_axes
    USE messy_main_channel,          ONLY: GET_CHANNEL_OBJECT_INFO
    USE messy_main_constants_mem,    ONLY: STRLEN_MEDIUM, STRLEN_ULONG
    USE messy_main_timer,            ONLY: lresume, lstart
    USE messy_main_tracer,           ONLY: NSETID, STRLEN_TRSET, get_tracer_set&
                                         , t_trinfo_list, TR_NEXIST
    USE messy_main_tools,            ONLY: find_next_free_unit


! ... LGTRSTR
!!#D attila +
    USE messy_attila_tools_e5,    ONLY: gp2lg_e5
!!#D attila -
!!#D clams +
! ... CLTRST
    USE messy_clams_tools_e5,     ONLY: gp2cl_e5
!!#D clams -


# 1234


    IMPLICIT NONE
    INTRINSIC :: ASSOCIATED, NULL, SIZE, TRIM

! LOCAL
    CHARACTER(LEN=*), PARAMETER  :: substr = 'tracer_init'
    INTEGER                      :: n       ! set counter
    INTEGER                      :: ntrac   ! number of tracers
    CHARACTER(LEN=STRLEN_TRSET)  :: setname ! tracer set name
    LOGICAL                      :: l_init  ! initialize this set ?
    TYPE(t_trinfo_list), POINTER :: til => NULL()
    TYPE(t_trinfo_tp), DIMENSION(:), POINTER :: ti  => NULL()
!
    INTEGER                      :: status  ! error status
    LOGICAL                      :: lskip   ! skip, if no uninitialized tracers
    INTEGER                      :: iunit   ! fortran unit for input file
    LOGICAL                      :: lex     ! file exists ?
!
! FOR REGRIDDING TO GLOBAL FIELD (ON I/O PE)
    REAL(DP), DIMENSION(:,:,:), POINTER :: zin => NULL()
!
! decomposed data field (local)
    REAL(DP), DIMENSION(:,:,:), POINTER :: zinl => NULL()

! Lagrange
    REAL(DP), DIMENSION(:),     POINTER :: zxt_lg => NULL()
    REAL(DP), DIMENSION(:),     POINTER :: zxt_cl => NULL()

!
! GRID
    TYPE (t_ncvar), DIMENSION(:), POINTER :: var => NULL() ! list of variables
    REAL(DP), DIMENSION(:,:,:,:), POINTER :: dat => NULL()
    CHARACTER(len=2*STRLEN_MEDIUM + 1)    :: cevar ! object of evar
    CHARACTER(len=STRLEN_MEDIUM)          :: basename
    CHARACTER(len=STRLEN_MEDIUM)          :: subname
    INTEGER                               :: isizev ! SIZE(evar)
    INTEGER                               :: i      ! species counter
    INTEGER, DIMENSION(:), ALLOCATABLE    :: nu, nr, ni ! counter
    INTEGER                               :: jt         ! tracer index in set
    INTEGER                               :: root_pe
    INTEGER                               :: work_loop
    LOGICAL,  SAVE                        :: lint    ! use input time ?
    INTEGER, DIMENSION(:), POINTER        :: RGT => NULL() ! regridding type
    TYPE (t_ncvar), DIMENSION(:), POINTER :: ovar  => NULL() ! list of variables
    TYPE (t_ncvar), DIMENSION(:), POINTER :: sovar => NULL() ! list of variables
    TYPE (t_geohybgrid)                   :: igrid   ! output grid info
    TYPE (t_geohybgrid)                   :: ogrid   ! output grid info
    INTEGER                               :: tc, tmin
    INTEGER,           PARAMETER          :: t_undef = -99
    LOGICAL                               :: ldompar = .FALSE.
    LOGICAL                               :: lvarpar = .FALSE.
    LOGICAL                               :: l_proc  = .FALSE.
    LOGICAL                               :: lpres   = .FALSE.
    LOGICAL                               :: lwork   = .FALSE.
    INTEGER                               :: ix
    INTEGER                     :: np
    CHARACTER(LEN=STRLEN_ULONG) :: infostr = ''
    LOGICAL :: linit
# 1312


    IF (l_tracer_initfromrestart .and. lstart) THEN
       CALL warning_bi('Tracer init from restart file:             ', substr)
       CALL warning_bi('This is a hack! Use it very carefully!     ', substr)
       CALL warning_bi('The dimensions need to fit perfectly, i.e.,', substr)
       CALL warning_bi('the same resolution is mandatory,          ', substr)
       CALL warning_bi('and exactly the same domain!               ', substr)
       CALL warning_bi('It does only work for the GP tracer set.   ', substr)
       CALL warning_bi('It does NOT work for ICON.                 ', substr)

       CALL main_channel_read_restart('tracer_gp')

       DO ix = 1, SIZE(ti_gp)
          CALL get_channel_object_info(status, 'tracer_gp'  &
               , TRIM(ti_gp(ix)%tp%ident%fullname), lrestart_read=linit )
          CALL channel_halt(substr, status)
          ti_gp(ix)%tp%meta%linit = ti_gp(ix)%tp%meta%linit .OR. linit
       END DO
    END IF

    np = dom_curid


    ldompar = .FALSE.

    lvarpar = .TRUE.
# 1341



# 1398

!end of #if defined(COSMO) || (defined(CESM1) && defined(HOMMESE))

    CALL start_message_bi(substr,'TRACER INITIALISATION',substr)

! CHECK IF PROCEDURE CAN BE SKIPPED, E.G. AFTER RESTART WITHOUT
! ADDING NEW TRACERS ...
! NOTE: lforce_init HAS BEEN TESTED ALREADY !!!
!       HERE IS TEST OF linit SUFFICIENT !!!
    lskip = lresume ! skip only after restart
    set_loop1: DO n=1, NSETID

       CALL get_tracer_set(status, n, setname, trlist=til, ntrac=ntrac &
            , l_init=l_init)
       CALL tracer_halt(substr, status)

! NO EMPTY SETS
       IF (ntrac == 0) CYCLE

! INITIALISATION MUST BE ALLOWED
       IF (.NOT. l_init) CYCLE

! CHECK FOR UNINITIALIZED TRACERS
       DO
          IF (.NOT. ASSOCIATED(til)) EXIT
! i = til%info%ident%idx
          IF (.NOT. til%info%meta%linit) lskip = .false.
          til => til%next
       END DO

    END DO set_loop1

    IF (lskip) THEN
       CALL end_message_bi(substr,'TRACER INITIALISATION (SKIPPED)',substr)
       RETURN
    END IF

    np = dom_curid

! LOCATE BASEMODEL GRID
    CALL INIT_GEOHYBGRID(ogrid)
    CALL LOCATE_GEOHYBGRID(status, BASEGRID_ID(np), grid=ogrid)

    IF (status /= 0) CALL error_bi(grid_error(status), substr)

    INQUIRE(file=TRIM(modstr)//'.nml', exist=lex)  ! now tracer.nml
    IF (lex) THEN
       iunit = find_next_free_unit(100,200)
    ELSE
       IF (p_parallel_io) THEN
          CALL RGMSG(substr, RGMLW, &
               'NAMELIST FILE '''//TRIM(modstr)//'.nml'' NOT FOUND !')
          CALL RGMSG(substr, RGMLWC, &
               'NO TRACER INITIALIZATION POSSIBLE !')
       END IF
    END IF

    IF (.NOT.lex) RETURN

! INIT
    ALLOCATE(ni(NSETID))
    ALLOCATE(nu(NSETID))
    ALLOCATE(nr(NSETID))
    nu(:) = 0
    nr(:) = 0
    ni(:) = 0


! ALLOCATE SPACE FOR I/O (global field)
    IF (p_parallel_io) THEN
       ALLOCATE(zin(nlon, nlev, ngl), STAT=status)
       CALL ERRMSG(substr,status,1)
    ELSE
       NULLIFY(zin)
    ENDIF


# 1479


! ALLOCATE decomposed data field (local)
    ALLOCATE(zinl(nproma,nlev,ngpblks), STAT=status)
    CALL ERRMSG(substr,status,2)

! START REGRIDDING
! EXAMPLE: REGRIDDING ALL VARIABLES IN ALL NAMELISTS
    RG_NML  = NML_NEXT  ! READ NEXT NAMELIST FROM FILE
    RG_CTRL = RG_SCAN

    regrid_loop: DO ! ENDLESS DO LOOP (MUST BE TERMINATED WITH EXIT)

       RG_STATUS = RGSTAT_NULL
       CALL INIT_PIMPGRID
       CALL INIT_PARALLEL(p_pe, p_nprocs, p_all_comm)

! INITIALISE
       CALL INIT_GEOHYBGRID(igrid)
       tmin  = t_undef
       tc    = t_undef

       IF (ldompar .OR. lvarpar .OR. p_parallel_io) THEN

          CALL READ_CONTROL(RG_CTRL, RG_NML, RG_STATUS    &
               , var, igrid, ogrid, RGT, lint, TRIM(modstr)//'.nml' &
               , infostr                                       &
               , iounit=iunit, ldomainpar=ldompar, lvarparallel=lvarpar &
               , lpresaxis=lpres, lwork=lwork)

       END IF

       CALL p_bcast (RG_STATUS, p_io)

       IF (RG_STATUS == RGSTAT_STOP) EXIT

       outer: IF (ldompar .OR. lvarpar .OR. p_parallel_io) THEN


! NCREGRID INTERPOLATION
          IF (lwork) &
               CALL REGRID_CONTROL(igrid, ogrid, var, ovar, RGT, lint &
               , lfirsto=(tc==tmin))
# 1659

! end of else: #if defined(1) || (defined(CESM1) && !defined(HOMMESE))

          IF (ASSOCIATED(RGT)) THEN
             DEALLOCATE(RGT) ; NULLIFY(RGT)
          ENDIF

       ENDIF outer

       do_work: DO work_loop = 0, nproc_work-1
          IF (lvarpar) THEN
             root_pe = pe_list(work_loop)
          ELSE
             root_pe = p_io
          ENDIF

          IF (ldompar) THEN
             isizev = SIZE(ovar)
          ELSE
             IF ( p_pe == root_pe ) isizev = SIZE(ovar)
             CALL p_bcast (isizev, root_pe)
          END IF

          IF ( p_pe == root_pe ) THEN
             CALL RGMSG(substr, RGMLVL, '')
             CALL RGMSG(substr, RGMLVL, 'SUBROUTINE '//TRIM(substr)//' REPORT:')
             CALL RGMSG(substr, RGMLVL, &
                  'FOUND ',isizev,' FIELD(S); CHECKING FOR TRACER ...')
          END IF

          l_proc = ldompar .OR.                             &
               ( (lvarpar .AND. p_pe == root_pe)        &
               .OR. (.NOT.lvarpar .AND. p_parallel_io) )

          species_loop: DO i = 1, isizev ! LOOP OVER SPECIES

             IF (l_proc) THEN

                CALL RGTOOL_CONVERT(ovar(i), dat, ogrid, order=repr_def_axes('x','z','n','y'))
                cevar = TRIM(var(i)%name)

             END IF

             IF (.NOT. ldompar) THEN
                CALL p_bcast(cevar, root_pe)
             END IF

             IF (.NOT. lvarpar) THEN
                IF (.NOT. ldompar) THEN
                   IF (p_pe == root_pe) zin(:,:,:) = dat(:,:,1,:)
                ENDIF
             ELSE
! lvarpar = T
                IF (p_pe == root_pe) THEN

                   IF(p_nprocs == 1 .OR. p_parallel_io)   THEN
                      zin(:,:,:) = dat(:,:,1,:)
                   ELSE

                      CALL p_send(dat(:,:,1,:), p_io, jt)

                   END IF
                ELSE IF (p_parallel_io .AND. p_pe /= root_pe)   THEN
                   IF(p_nprocs > 1)   THEN

                      CALL p_recv(zin, root_pe, jt)

                   END IF
                END IF
             END IF

             zinl(:,:,:) = 0.0_dp
             IF (ldompar) THEN
                zinl(:,:,:) = dat(:,:,1,:)
             ELSE
                CALL scatter_gp(zin, zinl, dcg)
             END IF

! HOOK FOR INITIALISATION OF PROGNOSTIC VARIABLES
             CALL init_pvar(TRIM(cevar), zinl)

! TRACER HANDLING STARTS HERE ...
             set_loop2: DO n=1, NSETID

                CALL get_tracer_set(status, n, setname, ti=ti, ntrac=ntrac &
                     , l_init=l_init)
                CALL tracer_halt(substr, status)

! NO EMPTY SETS
                IF (ntrac == 0) CYCLE

! INITIALISATION MUST BE ALLOWED
                IF (.NOT. l_init) CYCLE

                CALL full2base_sub(status, TRIM(cevar), basename, subname)
                CALL tracer_halt(substr, status)
!
                CALL get_tracer(status, setname               &
                     , TRIM(basename), TRIM(subname), idx=jt)
!
                tracer_exists: IF (status == TR_NEXIST) THEN
                   IF (p_pe == root_pe) THEN
                      CALL RGMSG(substr, RGMLVL, &
                           '  TRACER '''//TRIM(cevar)//&
                           &''' (SET '//TRIM(setname)//') NOT DEFINED')
                   END IF
                   nu(n) = nu(n) + 1
                ELSE IF (status /= 0) THEN
                   CALL tracer_halt(substr, status)
                ELSE
! skip if already initialised (from restart-file)
                   IF (ti(jt)%tp%meta%linit) THEN
                      IF ( p_pe == root_pe) THEN
                         CALL RGMSG(substr, RGMLVL, &
                              '  TRACER '''//TRIM(var(i)%name)&
                              &//''' (SET '//TRIM(setname)//&
                              &') ALREADY INITIALIZED (e.g. FROM RESTART)')
                      END IF
                      nr(n) = nr(n) + 1
                      CYCLE ! next species
                   END IF
!
                   IF ( p_pe == root_pe) THEN
                      CALL RGMSG(substr, RGMLVL, &
                           '  INITIALIZING TRACER '''//TRIM(var(i)%name)//&
                           &''' (SET '//TRIM(setname)//') ')
                   ENDIF

                   SELECT CASE (TRIM(setname))
!
                   CASE(GPTRSTR)
!
                      xt(:,:,jt,:) = zinl(:,:,:)
                      IF (lresume) xtm1(:,:,jt,:) = &
                           (1._DP - eps) * xt(:,:,jt,:)
! set flag indicating that tracer is already initialized
                      ti(jt)%tp%meta%linit = .TRUE.
!

                   CASE(LGTRSTR)
!
!!#D attila +
! distribute tracers over the processors (GP->LG)
                      zxt_lg => xt_a(:,1,jt,1)
                      CALL gp2lg_e5(zinl, zxt_lg)
                      IF (lresume) xtm1_a(:,:,jt,:) = &
                           (1._DP - eps) * xt_a(:,:,jt,:)
! set flag indicating that tracer is already initialized
                      ti(jt)%tp%meta%linit = .TRUE.
!!#D attila -

!!#D clams +
                   CASE(CLTRSTR)
! distribute tracers over the processors (GP->CL)
                      zxt_cl => xt_c(:,1,jt,1)
                      CALL gp2cl_e5(zinl, zxt_cl)
! Not leap-frog for CLaMS tracers ...
!!$                   IF (lresume) xtm1_cl(:,:,jt,:) = &
!!$                        (1._DP - eps) * xt_c(:,:,jt,:)
! set flag indicating that tracer is already initialized
                      ti(jt)%tp%meta%linit = .TRUE.
!!#D clams -

!
                   END SELECT

                   ni(n) = ni(n) + 1

                END IF tracer_exists

             END DO set_loop2

          END DO species_loop

       END DO do_work

       IF (ASSOCIATED(var)) THEN
          DO i=1,SIZE(var)
             CALL INIT_NCVAR(var(i))
          END DO
          DEALLOCATE(var)
       END IF
       NULLIFY(var)
       IF (ASSOCIATED(dat)) THEN
          DEALLOCATE(dat, STAT=status)
          CALL ERRMSG(substr,status,4)
       END IF
       NULLIFY(dat)
       IF (ASSOCIATED(ovar)) THEN
          DO i=1, SIZE(ovar)
             CALL INIT_NCVAR(ovar(i))
          END DO
          DEALLOCATE(ovar)
          NULLIFY(ovar)
       ENDIF

       IF (ASSOCIATED(sovar)) THEN
          DO i=1, SIZE(sovar)
             CALL INIT_NCVAR(sovar(i))
          END DO
          DEALLOCATE(sovar)
          NULLIFY(sovar)
       ENDIF

       set_loop3: DO n=1, NSETID

          CALL get_tracer_set(status, n, setname &
               , ntrac=ntrac, l_init=l_init)
          CALL tracer_halt(substr, status)
          IF (ntrac == 0) CYCLE
          IF (.NOT. l_init) CYCLE

          IF (p_parallel_io) THEN
             CALL RGMSG(substr, RGMLVL, &
                  'TRACER SET : '//TRIM(setname))
             CALL RGMSG(substr, RGMLVL, &
                  '... ',nu(n), &
                  ' UNRECOGNIZED NAMES')
             CALL RGMSG(substr, RGMLVL, &
                  '... ',nr(n), &
                  ' TRACER(S) ALREADY INITIALIZED (e.g. FROM RESTART)')
             CALL RGMSG(substr, RGMLVL, &
                  '... ',ni(n),' TRACER(S) INITITALIZED')
          END IF

       END DO set_loop3

       IF (p_parallel_io) THEN
          CALL RGMSG(substr, RGMLVL, 'END OF SUBROUTINE '&
               &//TRIM(substr)//' REPORT!')
          CALL RGMSG(substr, RGMLVL, '')
       END IF

    END DO regrid_loop ! ENDLESS DO LOOP
! END REGRIDDING

! CLEAN
    CALL INIT_GEOHYBGRID(ogrid)
    CALL INIT_GEOHYBGRID(igrid)

    IF (ASSOCIATED(zin)) THEN
       DEALLOCATE(zin, STAT=status)
       CALL ERRMSG(substr,status,5)
    END IF
    NULLIFY(zin)

    IF (ASSOCIATED(zinl)) THEN
       DEALLOCATE(zinl, STAT=status)
       CALL ERRMSG(substr,status,6)
    END IF
    NULLIFY(zinl)

    DEALLOCATE(nu)
    DEALLOCATE(nr)
    DEALLOCATE(ni)

    CALL end_message_bi(modstr,'TRACER INITIALISATION',substr)

!  ... of #if defined(1) || defined(COSMO) || defined(CESM1)

! ICON
# 2602

! of #ifdef ICON

  END SUBROUTINE TRACER_INIT

! ------------------------------------------------------------------


! -------------------------------------------------------------------
  SUBROUTINE setup_tracer_set_gp

! SETUP MEMORY FOR TRACERS IN GRIDPOINT REPRESENTATION

    USE messy_main_grid_def_mem_bi, ONLY: nproma, nlev, ngpblks
    USE messy_main_data_bi,         ONLY: l2tls
# 2619


    IMPLICIT NONE

! LOCAL
    CHARACTER(LEN=*), PARAMETER    :: substr = 'setup_tracer_set_gp'
    INTEGER                        :: status
    INTEGER, DIMENSION(3)          :: dims
# 2630



    dims(1) = nproma
    dims(2) = nlev
    dims(3) = ngpblks

! 4 time levels: xt, xtte, xtm1, xtf (the latter is 'extended')
! first 3 time levels are 'standard' (t, tendency, t-1) -> .TRUE.
! tracers can be initialised -> .TRUE.
    CALL setup_tracer_set(status, GPTRSTR, dims, 4, .TRUE., .TRUE.)
    CALL tracer_halt(substr, status)

# 2675

# 2686

! SETUP POINTERS TO GRIDPOINT TRACER MEMORY AND TRACER INFORMATION
    CALL get_tracer_set(status, GPTRSTR, trlist_gp, ti_gp, ntrac_gp &
         , xt=pxt, xtte=pxtte, xtm1=pxtm1, xmem=pxtf                &
# 2696

         )
    CALL tracer_halt(substr, status)

  END SUBROUTINE setup_tracer_set_gp
! -------------------------------------------------------------------

# 2745



! -------------------------------------------------------------------
  SUBROUTINE setup_tracer_set_cl

      USE messy_main_tracer_mem_bi,   ONLY: dnparts_max
      USE messy_main_grid_def_mem_bi, ONLY: nproma, nlev, ngpblks

! SETUP MEMORY FOR TRACERS IN CLaMS REPRESENTATION

    IMPLICIT NONE

! LOCAL
    CHARACTER(LEN=*), PARAMETER    :: substr = 'setup_tracer_set_cl'
    INTEGER                        :: status
    INTEGER, DIMENSION(3)          :: dims_cl
    INTEGER, DIMENSION(3)          :: dims_clgp

    dims_cl(1) = dnparts_max
    dims_cl(2) = 1
    dims_cl(3) = 1

! 3 time levels: xt_c, xtte_c, xtm1_c
! These 3 time levels are 'standard' (t, tendency, t-1) -> .TRUE.
! tracers can be initialiszed -> .TRUE.
    CALL setup_tracer_set(status, CLTRSTR, dims_cl, 2, .FALSE., .TRUE.)
    CALL tracer_halt(substr, status)

! SETUP POINTERS TO CLaMS TRACER MEMORY AND TRACER INFORMATION
    CALL get_tracer_set(status, CLTRSTR, trlist_cl, ti_cl, ntrac_cl &
         , xt=pxt_c, xmem=pxmem_c) !, xtte=pxtte_c, xtm1=pxtm1_c)
    CALL tracer_halt(substr, status)

    pxtm1_c => pxt_c(:,:,:,:,:)      ! special for CLaMS
    pxtte_c => pxmem_c(:,:,:,:,1:1)  ! ext. memory for tendency

    conversion_cl2gp: IF (l_conv_cl2gp) THEN

       CALL copy_tracer_set(status, CLTRSTR, CLGPTRSTR )
       CALL tracer_halt(substr, status)

       dims_clgp(1) = nproma
       dims_clgp(2) = nlev
       dims_clgp(3) = ngpblks

! only one time level, no standard, tracers shall not be externally
! initialized
       CALL setup_tracer_set(status, CLGPTRSTR, dims_clgp, 1, .FALSE., .FALSE.)
       CALL tracer_halt(substr, status)

       CALL get_tracer_set(status, CLGPTRSTR, trlist_clgp, ti_clgp, ntrac_clgp &
            , xt=pxt_clgp)!, xtte=pxtte_clgp, xtm1=pxtm1_clgp)
       CALL tracer_halt(substr, status)

    END IF conversion_cl2gp

  END SUBROUTINE setup_tracer_set_cl
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE setup_tracer_set_lg

! SETUP MEMORY FOR TRACERS IN LAGRANGIAN REPRESENTATION

    USE messy_main_grid_def_mem_bi, ONLY: nproma, nlev, ngpblks

    IMPLICIT NONE

    INTRINSIC :: ASSOCIATED, NULL

! LOCAL
    CHARACTER(LEN=*), PARAMETER    :: substr = 'setup_tracer_set_lg'
    INTEGER                        :: status
    INTEGER, DIMENSION(3)          :: dims
    TYPE(t_trinfo_list), POINTER   :: til => NULL()

    dims(1) = NCELL
    dims(2) = 1
    dims(3) = 1

! 4 time levels: xt_a, xtte_a, xtm1_a, xtf_a (the latter is 'extended')
! first 3 time levels are 'standard' (t, tendency, t-1) -> .TRUE.
! tracers can be initialiszed -> .TRUE.
    CALL setup_tracer_set(status, LGTRSTR, dims, 4, .TRUE., .TRUE.)
    CALL tracer_halt(substr, status)

! SETUP POINTERS TO LAGRANGIAN TRACER MEMORY AND TRACER INFORMATION
    CALL get_tracer_set(status, LGTRSTR, trlist_lg, ti_lg, ntrac_lg &
         , xt=pxt_a, xtte=pxtte_a, xtm1=pxtm1_a, xmem=pxtf_a)
    CALL tracer_halt(substr, status)

    til => trlist_lg
    DO
      IF (.NOT. ASSOCIATED(til)) EXIT
      IF (til%info%meta%cask_i(I_mix) == ON) THEN
        number_mix = number_mix + 1
      END IF
      til => til%next
    END DO

    conversion_lg2gp: IF (l_conv_lg2gp) THEN

! COPY META-INFORMATION
       CALL copy_tracer_set(status, LGTRSTR, LGGPTRSTR)
       CALL tracer_halt(substr, status)

       dims(1) = nproma
       dims(2) = nlev
       dims(3) = ngpblks

! only one time level, no standard, tracers shall not be externally
! initialized
       CALL setup_tracer_set(status, LGGPTRSTR, dims, 1, .FALSE., .FALSE.)
       CALL tracer_halt(substr, status)

! SETUP POINTERS TO MEMORY AND TRACER INFORMATION
       CALL get_tracer_set(status, LGGPTRSTR, trlist_lggp, ti_lggp &
            , ntrac_lggp, xt=pxt_lggp)
       CALL tracer_halt(substr, status)

    END IF conversion_lg2gp

  END SUBROUTINE setup_tracer_set_lg
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE setup_tracer_set_om
!!#D mpiom +
! SETUP MEMORY FOR TRACERS IN OCEAN

    USE messy_mpiom_mem_e5, ONLY: IE,JE,KE

    IMPLICIT NONE

! LOCAL
    CHARACTER(LEN=*), PARAMETER    :: substr = 'setup_tracer_set_om'
    INTEGER                        :: status
    INTEGER, DIMENSION(3)          :: dims

    dims(1) = IE
    dims(2) = JE
    dims(3) = KE

! 4 time levels: xt, xtte, xtm1, xtf (the latter is 'extended')
! first 3 time levels are 'standard' (t, tendency, t-1) -> .TRUE.
! tracers can be initialiszed -> .TRUE.
    CALL setup_tracer_set(status, OMTRSTR, dims, 1, .TRUE., .TRUE.)
    CALL tracer_halt(substr, status)

! SETUP POINTERS TO LAGRANGIAN TRACER MEMORY AND TRACER INFORMATION
    CALL get_tracer_set(status, OMTRSTR, trlist_om, ti_om, ntrac_om &
         , xt=pxt_om )
    CALL tracer_halt(substr, status)
!!#D mpiom -
  END SUBROUTINE setup_tracer_set_om
! -------------------------------------------------------------------


! =====================================================================
# 3790

! =====================================================================

! ----------------------------------------------------------------------
  SUBROUTINE main_tracer_fconv_loc(direction, callstr, TRSETSTR)

    USE messy_main_mpi_bi,           ONLY: p_pe
    USE messy_main_grid_def_mem_bi,  ONLY: jrow, kproma
    USE messy_main_timer,            ONLY: time_step_len
    USE messy_main_tracer_family_bi, ONLY: tracfamily_1_f2t, tracfamily_1_t2f &
                                         , tracfamily_2_sum, tracfamily_2_rsc

    IMPLICIT NONE

! I/O
    CHARACTER(len=3), INTENT(in) :: direction
    CHARACTER(len=*), INTENT(in) :: callstr
    CHARACTER(len=*), INTENT(in) :: TRSETSTR

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_fconv_loc'
    INTEGER                     :: status

    IF (.NOT. l_family) RETURN

    SELECT CASE (direction)
!
    CASE ('f2t','F2t','f2T','F2T')
!
       CALL tracfamily_1_f2t(status, callstr, p_pe, TRSETSTR, &
            time_step_len, jrow, kproma)
       CALL tracer_halt(substr, status)
!
    CASE ('t2f','T2f','t2F','T2F')
!
       CALL tracfamily_1_t2f(status, callstr, p_pe, TRSETSTR, &
            time_step_len, jrow, kproma)
       CALL tracer_halt(substr, status)
!
    CASE ('sum','SUM')
!
       CALL tracfamily_2_sum(TRSETSTR, jrow)
!
    CASE ('rsc','RSC')
!
       CALL tracfamily_2_rsc(TRSETSTR, time_step_len, jrow)
!
    CASE default
!
       status = 2010 ! UNKNOWN CONVERSION FLAG
       CALL tracer_halt(substr, status)
!
    END SELECT

  END SUBROUTINE main_tracer_fconv_loc
! ----------------------------------------------------------------------

! ----------------------------------------------------------------------
  SUBROUTINE main_tracer_fconv_glb(direction, callstr, TRSETSTR)

    USE messy_main_mpi_bi,           ONLY: p_pe
    USE messy_main_grid_def_mem_bi,  ONLY: nproma, npromz, ngpblks
    USE messy_main_timer,            ONLY: time_step_len
    USE messy_main_tracer_family_bi, ONLY: tracfamily_1_f2t, tracfamily_1_t2f &
                                         , tracfamily_2_sum, tracfamily_2_rsc

    IMPLICIT NONE

! I/O
    CHARACTER(len=3), INTENT(in) :: direction
    CHARACTER(len=*), INTENT(in) :: callstr
    CHARACTER(len=*), INTENT(in) :: TRSETSTR

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_fconv_glb'
    INTEGER :: status
    INTEGER :: jjrow, jp

    IF (.NOT. l_family) RETURN

    SELECT CASE (direction)
!
    CASE ('f2t','F2t','f2T','F2T')
!
       DO jjrow = 1, ngpblks

          IF (jjrow == ngpblks) THEN
             jp = npromz
          ELSE
             jp = nproma
          END IF
# 3883

          CALL tracfamily_1_f2t(status, callstr, p_pe, TRSETSTR, &
               time_step_len, jjrow, jp)
          CALL tracer_halt(substr, status)
       END DO
!
    CASE ('t2f','T2f','t2F','T2F')
!
       DO jjrow = 1, ngpblks

          IF (jjrow == ngpblks) THEN
             jp = npromz
          ELSE
             jp = nproma
          END IF
# 3900

          CALL tracfamily_1_t2f(status, callstr, p_pe, TRSETSTR, &
               time_step_len, jjrow, jp)
          CALL tracer_halt(substr, status)
       END DO
!
    CASE ('sum','SUM')
!
       DO jjrow = 1, ngpblks
          CALL tracfamily_2_sum(TRSETSTR, jjrow)
       END DO
!
    CASE ('rsc','RSC')
!
       DO jjrow = 1, ngpblks
          CALL tracfamily_2_rsc(TRSETSTR, time_step_len, jjrow)
       END DO
!
    CASE default
!
       status = 2010 ! UNKNOWN CONVERSION FLAG
       CALL tracer_halt(substr, status)
!
    END SELECT

  END SUBROUTINE main_tracer_fconv_glb
! ----------------------------------------------------------------------

! ----------------------------------------------------------------------
  SUBROUTINE main_tracer_write_output(flag)

    USE messy_main_mpi_bi,           ONLY: p_pe
    USE messy_main_grid_def_mem_bi,  ONLY: nproma, npromz, ngpblks
    USE messy_main_timer,            ONLY: time_step_len
    USE messy_main_tracer_family_bi, ONLY: tracfamily_1_t2f

    IMPLICIT NONE

! I/O
    INTEGER, INTENT(IN) :: flag

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_write_output'
    INTEGER :: status
    INTEGER :: jjrow, jp

!!#D attila +
    IF (l_conv_lg2gp) CALL tracer_out_conv_lg2gp(flag)
!!#D attila -
!!#D clams +
    IF (l_conv_cl2gp) CALL tracer_out_conv_cl2gp(flag)
!!#D clams -

    IF ( (l_family) .AND. (flag==1) ) THEN

! UPDATE FAMILIES TO BE CONSISTENT WITH TRACERS (FOR OUTPUT)
       DO jjrow = 1, ngpblks

          IF (jjrow == ngpblks) THEN
             jp = npromz
          ELSE
             jp = nproma
          END IF
# 3965

          CALL tracfamily_1_t2f(status, substr, p_pe, GPTRSTR, &
               time_step_len, jjrow, jp, .FALSE.)
          CALL tracer_halt(substr, status)
       END DO

    END IF

  END SUBROUTINE main_tracer_write_output
! ----------------------------------------------------------------------

!!#D attila +
! ----------------------------------------------------------------------
  SUBROUTINE tracer_out_conv_lg2gp(flag)

    USE messy_main_blather_bi,    ONLY: error_bi

    USE messy_attila_tools_e5,    ONLY: lg2gp_e5


    IMPLICIT NONE

! I/O
    INTEGER, INTENT(IN) :: flag

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'tracer_out_conv_lg2gp'

    IF (ntrac_lggp /= ntrac_lg) &
         CALL error_bi('number of tracers mismatch',substr)

    SELECT CASE(flag)
    CASE(1)
!

       CALL lg2gp_e5(qxt_a, xt_lggp          &
            , i_conv_lg2gp_mode              &
            , fill_value = r_conv_lg2gp_fill &
            , lmcons = l_conv_lg2gp_mc       &
            )

!
    CASE(2)
!
!!$       xt_lggp(:,:,:,:) = 0.0_DP
!
    CASE DEFAULT
!
       CALL error_bi('UNKNOWN FLAG !', substr)

    END SELECT

  END SUBROUTINE tracer_out_conv_lg2gp
! ----------------------------------------------------------------------
!!#D attila -

!!#D clams +
! ----------------------------------------------------------------------
  SUBROUTINE tracer_out_conv_cl2gp(flag)

    USE messy_main_blather_bi,    ONLY: error_bi

    USE messy_clams_tools_e5,     ONLY: cl2gp_e5

!!$    USE messy_main_constants_mem, ONLY: FLAGGED_BAD

    IMPLICIT NONE

! I/O
    INTEGER, INTENT(IN) :: flag

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'tracer_out_conv_cl2gp'

    IF (ntrac_clgp /= ntrac_cl) &
         CALL error_bi('number of tracers mismatch',substr)

    SELECT CASE(flag)
    CASE(1)
!

       CALL cl2gp_e5(qxt_c, xt_clgp          &
            , i_conv_cl2gp_mode              &
            , fill_value = r_conv_cl2gp_fill &
            )

!
    CASE(2)
!
!!$       xt_lggp(:,:,:,:) = 0.0_DP
!
    CASE DEFAULT
!
       CALL error_bi('UNKNOWN FLAG !', substr)

    END SELECT

  END SUBROUTINE tracer_out_conv_cl2gp
! ----------------------------------------------------------------------
!!#D clams -

! -------------------------------------------------------------------
  SUBROUTINE init_pvar(vname, dat)

    USE messy_main_timer,          ONLY: lresume
    USE messy_main_blather_bi,     ONLY: warning_bi, error_bi, info_bi
    USE messy_main_constants_mem,  ONLY: M_air, M_H2O
    USE messy_main_tools,          ONLY: int2str
    USE messy_main_data_bi,        ONLY: bmstr => modstr


   USE messy_main_data_bi,         ONLY: eps, q, qm1

# 4080

# 4083

! ### add new BMs here

    IMPLICIT NONE
    INTRINSIC :: TRIM, ADJUSTL

! I/O
    CHARACTER(LEN=*),           INTENT(IN) :: vname ! input variable name
    REAL(DP), DIMENSION(:,:,:), INTENT(IN) :: dat   ! data

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'init_pvar'
    REAL(DP),         PARAMETER :: scvmr = M_air/M_H2O
    LOGICAL, SAVE               :: lfirst = .TRUE.
    INTEGER                     :: i
    CHARACTER(LEN=4)            :: nstr = ''
    CHARACTER(LEN=4)            :: sstr = ''
    LOGICAL                     :: l_cycle

! NO RE_INITIALISTION AFTER RESTART (PROGNOSTIC VARIABLES NEED TO BE
! IN RESTART-FILES)
    IF (lresume) RETURN

    IF (TRIM(bmstr) == '') THEN
       IF (lfirst) THEN
          CALL warning_bi(&
               'prognostic variable initialisation not'//&
               &' implemented for this basemodel' &
               ,substr)
       END IF
       lfirst = .FALSE.
       RETURN
    ENDIF

    DO i=1, N_INI_MAX

       CALL int2str(nstr, i, ' ', '*')

! CHECK BASEMODEL INFO
       l_cycle = .FALSE.
       SELECT CASE(TRIM(ADJUSTL(ini_pvar(i)%basemodel)))
       CASE('ECHAM5','COSMO','CESM1') ! ### add new BMs here
! OK
       CASE('')
          IF (lfirst) THEN
             CALL warning_bi(&
                  'empty basemodel name at #'//TRIM(nstr), substr)
          END IF
          l_cycle = .TRUE.
       CASE DEFAULT
          CALL error_bi(&
               'unknown basemodel name at #'//TRIM(nstr), substr)
       END SELECT
       IF (l_cycle) CYCLE

       l_cycle = .FALSE.
! CHECK PROGNOSTIC VARIABLE NAME
       IF (TRIM(ADJUSTL(ini_pvar(i)%pvar)) == '') THEN
          IF (lfirst) THEN
             CALL warning_bi(&
                  'empty prognostic variable name at #'//TRIM(nstr), substr)
          END IF
          l_cycle = .TRUE.
       ENDIF
       IF (l_cycle) CYCLE

! CHECK INPUT VARIABLE NAME
       IF (TRIM(ADJUSTL(ini_pvar(i)%inp)) == '') THEN
          CALL error_bi(&
               'empty prognostic variable name at #'//TRIM(nstr), substr)
       ENDIF
!
! NOTHING ELSE TODO, IF INPUT VARIABLE NAME DOES NOT MATCH
       IF (TRIM(ADJUSTL(ini_pvar(i)%inp)) /= TRIM(ADJUSTL(vname))) CYCLE

       l_cycle = .FALSE.
! CHECK BASEMODEL
       IF (TRIM(ADJUSTL(ini_pvar(i)%basemodel)) /= TRIM(bmstr)) THEN
          CALL warning_bi(&
               'initialsiation of prognostic variable '//&
               &TRIM(ini_pvar(i)%pvar)//' at #'//TRIM(nstr)//&
               &'matches input variable, but not for basemodel '//TRIM(bmstr) &
               , substr)
          l_cycle = .TRUE.
       END IF
       IF (l_cycle) CYCLE

       CALL int2str(sstr, ini_pvar(i)%switch, ' ', '*')
       CALL info_bi('initialising prognostic variable '//&
            &TRIM(ini_pvar(i)%pvar)//' with'//&
            &' input variable '//TRIM(ini_pvar(i)%inp)//&
            &' (# '//TRIM(nstr)//', method '//TRIM(sstr)//')' ,substr)
       SELECT CASE(TRIM(ADJUSTL(ini_pvar(i)%pvar)))


          CASE('q')
             SELECT CASE(ini_pvar(i)%switch)
                CASE(0) ! input is already in [kg/kg]
                   q(:,:,:)   = dat(:,:,:)
                   qm1(:,:,:) = (1._DP - eps) * q(:,:,:)
                CASE(1) ! convert from [mol/mol] to [kg/kg]
                   q(:,:,:)   = dat(:,:,:)/(scvmr+dat(:,:,:))
                   qm1(:,:,:) = (1._DP - eps) * q(:,:,:)
                CASE DEFAULT
                   CALL error_bi('unknown method',substr)
             END SELECT
# 4193



# 4198


! ### add new BMS here

          CASE DEFAULT
             CALL error_bi(&
                  'unknown prognostic variable '//TRIM(ini_pvar(i)%pvar)//&
                  ' at #'//TRIM(nstr)//&
                  &' (or not yet implemented for basemodel'//&
                  &TRIM(bmstr)//')'&
                  , substr)

       END SELECT

    END DO

    lfirst = .FALSE.

  END SUBROUTINE init_pvar
! -------------------------------------------------------------------

! -------------------------------------------------------------------
  SUBROUTINE main_tracer_read_nml_cpl(status, iou)

! TRACER MODULE ROUTINE (CORE)
!
! READ TRACER NAMELIST, CHECK IT, AND INITIALIZE GLOBAL VARIABLES
!
! Author: Patrick Joeckel, MPICH, Jul 2003

    USE messy_main_tools, ONLY: read_nml_open, read_nml_check, read_nml_close


!!#D attila +
    USE messy_attila_tools_e5, ONLY: LG2GP_SUM, LG2GP_AVE, LG2GP_STD &
                                   , LG2GP_AVEGT0
!!#D attila -
!!#D clams +
    USE messy_clams_tools_e5, ONLY: CL2GP_SUM
!!#D clams -


    IMPLICIT NONE

! I/O
    INTEGER, INTENT(OUT) :: status ! error status
    INTEGER, INTENT(IN)  :: iou    ! logical I/O unit

    NAMELIST /CPL/ l_tracer_init, l_tracer_initfromrestart &
         , l_conv_lg2gp &
         , i_conv_lg2gp_mode, r_conv_lg2gp_fill, l_conv_lg2gp_mc &
         , ini_pvar     &
         , n_trcr_block &
         , l_conv_cl2gp, i_conv_cl2gp_mode, r_conv_cl2gp_fill

! LOCAL
    CHARACTER(LEN=*), PARAMETER :: substr = 'main_tracer_read_nml_cpl'
    LOGICAL                     :: lex          ! file exists ?
    INTEGER                     :: fstat        ! file status

! INITIALIZE
    status = 1 ! ERROR

! INITIALIZE GLOBAL CONTROL VARIABLES
! -> DEFAULT VALUES ARE SET AT DECLARATION ABOVE

    CALL read_nml_open(lex, substr, iou, 'CPL', modstr)
    IF (.not.lex) RETURN    ! <modstr>.nml does not exist

    READ(iou, NML=CPL, IOSTAT=fstat)
    CALL read_nml_check(fstat, substr, iou, 'CPL', modstr)
    IF (fstat /= 0) RETURN  ! error while reading namelist

!!#D attila +
    IF (l_conv_lg2gp) THEN
       WRITE(*,*) '  CONVERSION OF LG TO GP       : ON '
       WRITE(*,*) '                    MODE       : ', i_conv_lg2gp_mode

       SELECT CASE (i_conv_lg2gp_mode)
          CASE(LG2GP_SUM)
             WRITE(*,*) '                    ===>       : LG2GP_SUM'
          CASE(LG2GP_AVE)
             WRITE(*,*) '                    ===>       : LG2GP_AVE'
          CASE(LG2GP_STD)
             WRITE(*,*) '                    ===>       : LG2GP_STD'
          CASE(LG2GP_AVEGT0)
             WRITE(*,*) '                    ===>       : LG2GP_AVEGT0'
          CASE DEFAULT
             WRITE(*,*) '                    ===>       : UNKNOWN (ERROR)'
             RETURN
       END SELECT

       WRITE(*,*) '                    MODE       : ',i_conv_lg2gp_mode
       WRITE(*,*) '              FILL VALUE       : ',r_conv_lg2gp_fill
       IF (l_conv_lg2gp_mc) THEN
          WRITE(*,*) '       MASS CONSERVATION       : ON '
       ELSE
          WRITE(*,*) '       MASS CONSERVATION       : OFF '
       END IF
    ELSE
       WRITE(*,*) '  CONVERSION OF LG TO GP       : OFF'
    END IF
!!#D attila -

!!#D clams +
    IF (l_conv_cl2gp) THEN
       WRITE(*,*) '  CONVERSION OF CL TO GP       : ON '
       WRITE(*,*) '                    MODE       : ', i_conv_cl2gp_mode

       SELECT CASE (i_conv_cl2gp_mode)
          CASE(CL2GP_SUM)
             WRITE(*,*) '                    ===>       : CL2GP_SUM'
          CASE(LG2GP_AVE)
             WRITE(*,*) '                    ===>       : CL2GP_AVE'
          CASE(LG2GP_STD)
             WRITE(*,*) '                    ===>       : CL2GP_STD'
          CASE(LG2GP_AVEGT0)
             WRITE(*,*) '                    ===>       : CL2GP_AVEGT0'
          CASE DEFAULT
             WRITE(*,*) '                    ===>       : UNKNOWN (ERROR)'
             RETURN
       END SELECT

       WRITE(*,*) '              FILL VALUE       : ',r_conv_cl2gp_fill
     ELSE
       WRITE(*,*) '  CONVERSION OF CL TO GP       : OFF'
     ENDIF
!!#D clams -

# 4329


    CALL read_nml_close(substr, iou, modstr)

    status = 0  ! no ERROR

  END SUBROUTINE main_tracer_read_nml_cpl
! -------------------------------------------------------------------

! **********************************************************************+
END MODULE messy_main_tracer_bi
! **********************************************************************+
