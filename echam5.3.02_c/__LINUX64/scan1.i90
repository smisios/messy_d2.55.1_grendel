# 1 "../src/scan1.f90"
SUBROUTINE scan1

! Description:
!
! First three scans over the latitude lines in controlling the computations
! in Fourier space and the adiabatic part of grid point
! calculations including different transport schemes
!
! Method:
!
! This subroutine reads symmetric and antisymmetric parts
! of *Fourier coefficients produced by the scans controlling the
! inverse *Legendre transforms. It then scans over the latitude
! lines three times to perform the 2nd part of computations in
! *Fourier space and computes adiabatic tendencies in grid-point
! space including "Spitfire" transport.
!
! *scan1* is called from *stepon*
!
! Externals.:
! *ffti*      inverse *fourier transforms.
! *tf1*       time filter (part 1)
! *tf2*       time filter (part 2)
! *dyn*       adiabatic tendencies (except Spitfire-variables)
!
! *setv*      Spitfire advection
! *vadvn*            "
! *seth*             "
! *hadvn*            "
! *spitfill*  copy data for Spitfire input
! *spitten*   compute tendencies of Spitfire
!
! *gpc*       grid point computations.
! *statd*     statistics for dynamic
! *prestat*   prepare statistics and budgets.
! *postatd*   complete statistics for dynamics.
! *maxwind*   compute maximum wind
!
! Authors:
!
! U. Schlese, DKRZ, February 1994, original source
! L. Kornblueh, MPI, May 1998, f90 rewrite
! U. Schulzweida, MPI, May 1998, f90 rewrite
! I. Kirchner, MPI, October 1998, tendency diagnostics
! L. Kornblueh, MPI, June 1999, parallel version (MPI based)
! T. Diehl, DKRZ, July 1999, parallel version
! A. Rhodin, MPI, July 1999, parallel version    (Transpositions)
! U. Schlese, DKRZ, October 1999 , preliminary SPITFIRE version
!                                  subroutine renamed
! I. Kirchner, MPI, July 2000, revision tendency diagnostics
! I. Kirchner, MPI, November 2000, date/time control
! U. Schulzweida, MPI, May 2002, blocking (nproma)
! L. Kornblueh, MPI, July 2002, parallelization and blocking of HD model
! L. Kornblueh, MPI, August 2002, longitudinal wind velocity derivatives
!                                 from Fourier space
! L. Kornblueh, MPI, April 2003, added port test
! L. Kornblueh, MPI, October 2003, reactivated AMIP2 global tests
!
! for more details see file AUTHORS
!
  USE mo_kind,          ONLY: dp
  USE mo_constants,     ONLY: a
# 66

  USE mo_control,       ONLY: ltdiag, ngl, nlev, nlevp1, &
                              ltimer

  USE mo_port_test,     ONLY: lport
  USE mo_diag_tendency, ONLY: diag_fftd, diag_spectrans
# 77

  USE mo_doctor,        ONLY: nout
  USE mo_geoloc,        ONLY: budw_2d
# 85

  USE mo_memory_gl,     ONLY: q, xl, xi, xt, xt_a, & ! mz_pj_20030930
                              xt_c ! op_sb_201901007
  USE mo_memory_g1a,    ONLY: alpsm1, dm1, qm1, tm1, vom1, xlm1, xim1, &
                              xtm1, dalpslm1, dalpsmm1, &
                              xtm1_a, & ! mz_pj_20030930
                              xtm1_c    ! op_sb_20191007
  USE mo_memory_g1b,    ONLY: alpsf, df, qf, tf, vof, xlf, xif, xtf, &
                              xtf_a ! mz_pj_20030930
  USE messy_main_grid_def_mem_bi, ONLY: nrow

  USE mo_memory_g2a,    ONLY: um1, vm1, dtlm1, dtmm1, dudlm1, dvdlm1
  USE mo_memory_g2b,    ONLY: uf, vf, dudlf, dvdlf
  USE mo_memory_g3b,    ONLY: aps
  USE mo_legendre,      ONLY: rnmd
  USE mo_hyb,           ONLY: apsurf
# 103

# 109

  USE mo_scan_buffer,   ONLY: vo, d, t, alps, u, v, &
# 113

                              qte, xlte, xite, xtte, &
                              rh, dm, vom, vol, &
                              dalpsl, &
                              dalpsm, dudl, dvdl, &
                              dtl, dtm, xtte_a, & ! mz_pj_20030930
                              xtte_c ! op_sb_20191007

  USE mo_memory_ls,     ONLY: ld, ltp, lu0, lvo
# 124

! mz_rs_20040329+
  USE messy_main_tracer_mem_bi, ONLY: ntrac => ntrac_gp, ntrac_a => ntrac_lg &
                                    , ntrac_cl         & ! op_sb_20191007
                                    , ON, ti_gp, ti_lg & ! mz_ak_20040512
                                    , ti_cl            & ! op_sb_20191007
                                    , I_integrate
! mz_rs_20040329-

  USE mo_mpi,           ONLY: p_parallel_io
  USE mo_decomposition, ONLY: ldc=>local_decomposition
  USE mo_call_trans,    ONLY: legendre_to_spectral, legendre_to_fourier, &
                              fourier_to_gridpoint, fourier_to_legendre, &
                              gridpoint_to_fourier,                      &
                              test_scan_buffer, test_memory_f
  USE mo_global_op,     ONLY: sum_latit_sl, sum_global
# 143

  USE mo_test_trans
# 149

  USE mo_time_control,  ONLY: &
       lstart, lresume, get_time_step, time_step_len


  USE mo_advection        
  USE mo_semi_lagrangian, ONLY: setup_semi_lagrangian, extend_semi_lagrangian,&
                                semi_lagrangian_transport, mass_fixer
  USE mo_spitfire,        ONLY: setup_spitfire, spitfire_transport, &
                                spitfire_tendencies
  USE mo_tpcore,          ONLY: setup_tpcore, tpcore_transport, &
                                tpcore_tendencies
  USE mo_timer,           ONLY: timer_start, timer_stop, &
                                timer_spitfire, &
                                timer_tpcore,   &
                                timer_slt
  USE mo_exception,       ONLY: message, message_text
# 169


  USE messy_main_data_bi, ONLY: etadot_3d ! mz_mt_20030625


  IMPLICIT NONE

! Local arrays
!
# 182

! mz_pj_20041026+
  REAL(dp):: ulz   (      nlev,  ngl),    &! dyn, maxwind
             vmaxz (      nlev,  ngl)      ! dyn, maxwind
  REAL(dp), DIMENSION(:,:,:), POINTER :: etadot
! mz_pj_20041026-


  REAL(dp):: alpha(nacnst), &
             hw1(nacnst),hw1p(nacnst),hw2(nacnst),hw3(nacnst),                 &
             hw1lat(nacnst,nalat), hw2lat(nacnst,nalat), hw3lat(nacnst,nalat), &
             qfcst(nalond,nalev,nacnst,nalatd,2)
# 196


!  Local parameters:
  INTEGER, PARAMETER :: itermn = 1, itermx = 4
 
!  Local scalars:
  REAL(dp):: hwps, hwpsm1, pscor, psm1cor, ra, zpref, ztodt

  INTEGER :: iter, jglat, m, jrow

! Bounds on this PE
  INTEGER :: ngpblks, nproma

  INTEGER :: istep

  REAL(dp), POINTER :: znapsm1(:,:) => NULL(), znaps(:,:) => NULL()

  LOGICAL       :: col_1d   ! column model is running
  LOGICAL       :: ldo_advection ! perform transport of tracers

! Variables needed by the port test

  INTEGER, ALLOCATABLE :: iseed(:) 
  INTEGER :: isize
  INTEGER :: ipos(3)   
  REAL(dp):: zrn(2)
  LOGICAL, SAVE :: lstart_port = .TRUE.


  INTEGER :: jt ! mz_ak_20040512

!  External subroutines
! op_pj_20130407+
# 234

  EXTERNAL dyn, ewd, sym2, fftd, ffti, gpc, ltd, maxwind,       &
           si2,  sym1, tf1, tf2

! op_pj_20130407-

!  Intrinsic functions
  INTRINSIC EXP, SUM


!call ftrace_region_begin('scan1_pre_dyn_barrier')
!call p_barrier (p_all_comm)
!call ftrace_region_end('scan1_pre_dyn_barrier')

!  Executable statements

  etadot => etadot_3d(:,:,:)    ! mz_pj_20041026


  istep = get_time_step()

! bounds on theis PE

  ngpblks = ldc% ngpblks ! number of rows
  col_1d = ldc%col_1d

! flag to run transport routine

  ldo_advection = iadvec /= no_advection .AND. .NOT. col_1d

  ztodt = time_step_len

  ra = 1._dp/a

!-- 1.2 Preset spectral components

!$OMP PARALLEL
!$OMP WORKSHARE
  lvo(:,:,:) = 0.0_dp
  ld(:,:,:)  = 0.0_dp
  ltp(:,:,:) = 0.0_dp
  lu0(:,:)   = 0.0_dp
!$OMP END WORKSHARE
!$OMP END PARALLEL

# 281


# 286


! Prepare scan buffer (see bufsc1)
# 293


  CALL test_scan_buffer ('before sym2')

! calculations in legendre space and fft taken out of main loop:

!-- 2.3 Second part of computations in *fourier space
!       (symmetric/antisymmetric recombination,
!        zonal derivatives)

!-- 2.3.1 Computation of *Fourier components from their symmetric
!         and antisymmetric parts and retrievial of u and v.

  CALL test_memory_f    ('before sym2')

  CALL sym2

  CALL test_scan_buffer ('after sym2')

  CALL legendre_to_fourier

!-- 2.3.2 East-west derivatives

  CALL ewd

!-- 2.4 Inverse fast *fourier transforms

  CALL ffti

  CALL fourier_to_gridpoint

# 326


  CALL test_scan_buffer ('after fourier_to_gridpoint')

!-- 2.5 First part of grid point computations

!-- 2.5.1 Explicit dynamics for eulerian variables

! Compute t-dt values at model start.

  IF (lstart) THEN
!$OMP PARALLEL
!$OMP WORKSHARE
     vom1   (:,:,:) =   vo (:,:,:)
     dm1    (:,:,:) =    d (:,:,:)
!DIR$ CONCURRENT
     qm1    (:,:,:) =    q (:,:,:)
!DIR$ CONCURRENT
     xlm1   (:,:,:) =    xl(:,:,:)
!DIR$ CONCURRENT
     xim1   (:,:,:) =    xi(:,:,:)
     tm1    (:,:,:) =    t (:,:,:)
     dtlm1 (:,:,:)  =  dtl (:,:,:)
     dtmm1 (:,:,:)  =  dtm (:,:,:)
     alpsm1 (:  ,:) = alps (:  ,:)
     dalpslm1(:,:)  = dalpsl(:,:)
     dalpsmm1(:,:)  = dalpsm(:,:)
     um1    (:,:,:) =    u (:,:,:)
     vm1    (:,:,:) =    v (:,:,:)
     dudlm1 (:,:,:) = dudl (:,:,:)
     dvdlm1 (:,:,:) = dvdl (:,:,:)
!$OMP END WORKSHARE
!$OMP END PARALLEL
     IF (ntrac > 0) THEN
!$OMP PARALLEL
!$OMP WORKSHARE
!DIR$ CONCURRENT
       xtm1(:,:,:,:) = xt(:,:,:,:)
!$OMP END WORKSHARE
!$OMP END PARALLEL
     ENDIF

     IF (ntrac_a > 0) THEN
!$OMP PARALLEL
!$OMP WORKSHARE
!DIR$ CONCURRENT
        xtm1_a(:,:,:,:) = xt_a(:,:,:,:) ! mz_pj_20030930
!$OMP END WORKSHARE
!$OMP END PARALLEL
     END IF
!!$     IF (ntrac_cl > 0) THEN ! obsolete, becasue xtm1 = xt for CLaMS
!!$!$OMP PARALLEL
!!$!$OMP WORKSHARE
!!$!DIR$ CONCURRENT
!!$        xtm1_c(:,:,:,:) = xt_c(:,:,:,:)
!!$!$OMP END WORKSHARE
!!$!$OMP END PARALLEL
!!$     END IF

  END IF

  IF (lport .AND. lstart_port) THEN
    lstart_port = .FALSE.
    CALL RANDOM_SEED   (size=isize)
    ALLOCATE (iseed(isize))
    CALL SYSTEM_CLOCK  (iseed(1))
    iseed(:) = iseed(1)
    CALL RANDOM_SEED   (put=iseed)
    CALL RANDOM_NUMBER (zrn)
    DEALLOCATE (iseed)
    
    ipos(1) = INT((SIZE(tm1,1)-1)*zrn(1))+1
    ipos(2) = nlev
    ipos(3) = INT((SIZE(tm1,3)-1)*zrn(2))+1
    
    WRITE (message_text,'(a,3i4,e30.19,e30.19)')    &
         'Perturbation on T    ', ipos, &
         tm1(ipos(1),ipos(2),ipos(3)),   &
         2*SPACING(tm1(ipos(1),ipos(2),ipos(3))) 
    CALL message('scan1', TRIM(message_text))
    
    tm1(ipos(1),ipos(2),ipos(3)) = tm1(ipos(1),ipos(2),ipos(3)) &
         + 2*SPACING(tm1(ipos(1),ipos(2),ipos(3))) 
    
    WRITE (message_text,'(a,3i4,e30.19)') &
         'Perturbed value of T ', ipos, &
         tm1(ipos(1),ipos(2),ipos(3))
    CALL message('scan1', TRIM(message_text))
    
  END IF
  
! Blank tendencies

# 424


!$OMP PARALLEL
!$OMP WORKSHARE
  qte (:,:,:)   = 0.0_dp
  xlte(:,:,:)   = 0.0_dp
  xite(:,:,:)   = 0.0_dp
  xtte(:,:,:,:) = 0.0_dp
!$OMP END WORKSHARE
!$OMP END PARALLEL

  IF (ntrac_a > 0) THEN
!$OMP PARALLEL
!$OMP WORKSHARE
     xtte_a(:,:,:,:) = 0.0_dp ! mz_pj_20030930
!$OMP END WORKSHARE
!$OMP END PARALLEL
  END IF
! op_sb_20191007+
  IF (ntrac_cl > 0) THEN
!$OMP PARALLEL
!$OMP WORKSHARE
     xtte_c(:,:,:,:) = 0.0_dp  
!$OMP END WORKSHARE
!$OMP END PARALLEL
  END IF
! op_sb_20191007-


! um_ak_20140327+ removed
!!$#ifdef 1
!!$  CALL messy_init_loop ! um_ak_20131114
!!$#endif
! um_ak_20140327- removed

! Eulerian advection, energy conversion term
! and computation of vertical velocity (etatdot)

  CALL dyn (etadot, ulz, vmaxz)

# 466


  CALL test_scan_buffer ('after dyn')

! Second part of time filter

  CALL tf2

!call ftrace_region_begin('scan1_post_dyn_barrier')
!call p_barrier (p_all_comm)
!call ftrace_region_end('scan1_post_dyn_barrier')

  CALL test_scan_buffer ('after tf2')

# 482


  CALL test_scan_buffer ('after diagnostics of the dynamic')

!call ftrace_region_begin('scan1_pre_advect_barrier')
!call p_barrier (p_all_comm)
!call ftrace_region_end('scan1_pre_advect_barrier')


! um_ak_20090305+


  IF ( lstart ) THEN
    DO jrow = 1, ngpblks 
       CALL initemp(jrow)
    ENDDO
  ENDIF


! um_ak_20090305-
! mz_pj_20030925+
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  CALL messy_global_start  ! interface to submodels after 'dyn'
!                          ! in order to allow for use of 'etadot' in
!                          ! alternative advection algorithms ...
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! mz_pj_20030925-
! um_ak_20080709+
  CALL messy_beforeadv
! um_ak_20080709-

!-- 2.8 advection ...

  IF (ldo_advection) THEN

    SELECT CASE (iadvec)
    CASE (semi_lagrangian)
      IF (ltimer) CALL timer_start(timer_slt)
      CALL setup_semi_lagrangian
      IF (ltimer) CALL timer_stop(timer_slt)
    CASE (spitfire)
      IF (ltimer) CALL timer_start(timer_spitfire)
      CALL setup_spitfire 
      IF (ltimer) CALL timer_stop(timer_spitfire)
    CASE (tpcore)
      IF (ltimer) CALL timer_start(timer_tpcore)
      CALL setup_tpcore  
      IF (ltimer) CALL timer_stop(timer_tpcore)
    END SELECT

    IF (iadvec == semi_lagrangian) THEN
      IF (ltimer) CALL timer_start(timer_slt)
      CALL extend_semi_lagrangian

      IF (lstart) THEN
        iter = itermx
      ELSE
        iter = itermn
      END IF

# 545

      CALL semi_lagrangian_transport(ztodt,ra,iter,etadot, &
           qfcst, hw1lat, hw2lat, hw3lat)

      IF (ltimer) CALL timer_stop(timer_slt)
    END IF

!--  2.5.2 Zonal mass of dry air

    IF (.NOT. ASSOCIATED(znapsm1)) THEN
       ALLOCATE(znapsm1(SIZE(aps,1), SIZE(aps,2)))
       ALLOCATE(znaps(SIZE(aps,1), SIZE(aps,2)))
    END IF
    
    znapsm1(:,:) = budw_2d(:,:)*EXP(alpsm1(:,:))
    znaps(:,:)   = budw_2d(:,:)*aps(:,:)

!-- 2.5.3 Global mass of dry air

    hwpsm1 = sum_global(znapsm1) 
    hwps   = sum_global(znaps)
    
    IF (iadvec == semi_lagrangian) THEN

! hwXlat are return values of the semi Lagrangian
 
      hw1(:) = sum_latit_sl ( hw1lat(:,:))
      hw2(:) = sum_latit_sl ( hw2lat(:,:))
      hw3(:) = sum_latit_sl ( hw3lat(:,:))
      
      DO m = 1, nacnst
        IF (hw3(m) > 0.0_dp) THEN
          alpha(m) = (hw1(m)-hw2(m))/hw3(m)
        ELSE
          alpha(m) = 0.0_dp
        END IF
        hw1p(m) = hw1(m)/hwps
      END DO
    END IF

! Coefficients for air mass correction

    zpref = apsurf
    psm1cor = zpref/hwpsm1
    pscor = zpref/hwps

# 611

    
    IF (iadvec == spitfire) THEN
      IF (ltimer) CALL timer_start(timer_spitfire)
       CALL spitfire_transport(etadot, ztodt, istep)
      IF (ltimer) CALL timer_stop(timer_spitfire)
    ELSE IF (iadvec == tpcore) THEN
     IF (ltimer) CALL timer_start(timer_tpcore)
      CALL tpcore_transport
     IF (ltimer) CALL timer_stop(timer_tpcore)
    END IF

  ENDIF

  CALL test_scan_buffer ('before calculating advection tendencies')

!-- 2.8.1 Tendencies of advection and mass correction of dry air

  IF (ldo_advection) then

    SELECT CASE (iadvec)
    CASE (semi_lagrangian)
      IF (ltimer) CALL timer_start(timer_slt)
# 636

      CALL mass_fixer(qfcst,alpha,psm1cor,pscor,ztodt)

      IF (ltimer) CALL timer_stop(timer_slt)
    CASE (spitfire)
      IF (ltimer) CALL timer_start(timer_spitfire)
      CALL spitfire_tendencies (psm1cor, pscor)
      IF (ltimer) CALL timer_stop(timer_spitfire)
    CASE (tpcore)
      IF (ltimer) CALL timer_start(timer_tpcore)
      CALL tpcore_tendencies (psm1cor, pscor) 
      IF (ltimer) CALL timer_stop(timer_tpcore)
    END SELECT
  ENDIF

!call ftrace_region_begin('scan1_post_advect_barrier')
!call p_barrier (p_all_comm)
!call ftrace_region_end('scan1_post_advect_barrier')

# 657



! mz_pj_20070618+
  CALL messy_afteradv
! mz_pj_20070618-

!-- 3. Final subscan

!-- 3.2 Start of mainloop for final subscan

  CALL test_scan_buffer ('before start of final subscan')

!-- 3. Final subscan

  CALL si1_extended_const

! First part of time filtering for next time step

  CALL tf1

# 684


!-- Initialisation of surface and soil temperatures.


  IF ( lstart ) THEN
    DO jrow = 1, ngpblks 
      CALL initemp(jrow)
    ENDDO
  ENDIF


!call ftrace_region_begin('scan1_pre_gpc_barrier')
!call p_barrier (p_all_comm)
!call ftrace_region_end('scan1_pre_gpc_barrier')

!-- 3.2 Start of mainloop for final subscan

!!! -- !CSD$ PARALLEL DO PRIVATE(nproma,jglat,jrow) SCHEDULE(STATIC,1)
!!! -- !$OMP PARALLEL PRIVATE(nproma,jglat,jrow)
!!! -- !$OMP DO SCHEDULE(STATIC,1)
  DO jrow = 1, ngpblks          ! local number of rows

    IF ( jrow == ldc% ngpblks ) THEN
      nproma = ldc% npromz
    ELSE
      nproma = ldc% nproma
    END IF

    IF ( ldc% lreg ) THEN
      jglat = ldc%glat(jrow)    ! global index north -> south
    ELSE
      jglat = 1
    END IF


!mz_pj_20040326+
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    nrow(1) = 0
    nrow(2) = jrow   
    nrow(3) = jglat
    CALL messy_local_start
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!mz_pj_20040326-



!-- 3.4 2nd part of grid point computations

!-- 3.4.2 Physics and semi-implicit adjustment in grid space

    CALL gpc(jrow, jglat)

!call ftrace_region_begin('scan1_post_gpc_barrier')
!call p_barrier (p_all_comm)
!call ftrace_region_end('scan1_post_gpc_barrier')



!mz_pj_20040326+
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    CALL messy_local_end
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!mz_pj_20040326-


!-- explicit integration in column model

# 754


!-- 4. Grid point contributions to the semi implicit
# 772

!!$#ifdef 1
!!$    ! mz_pj_20030930+
!!$    ! JROW = ldc%ngpblks -> TRANSFER AT END OF THE LOOP
!!$    IF (jrow == ldc%ngpblks) THEN
!!$       IF (ntrac_a > 0)   xt_a(:,:,:,:) =  xtm1_a(:,:,:,:)
!!$    END IF
!!$    ! mz_pj_20030930-
!!$#endif

!-- 3.8 Compute contributions to symmetric and
!       antisymmetric Fourier components.
!-- 4.1 End of main loop for final subscan

  END DO
!!! -- !$OMP END DO
!!! -- !$OMP END PARALLEL
!!! -- !CSD$ END PARALLEL DO


!mz_pj_20040326+
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  CALL messy_global_end
! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!mz_pj_20040326-

! mz_pj_20060926+
! moved this block outside local (jrow) loop above; this allows
! messy_global_end before time filter ...
  DO jrow=1, ngpblks 

    IF ( jrow == ldc% ngpblks ) THEN
      nproma = ldc% npromz
    ELSE
      nproma = ldc% nproma
    END IF

    IF ( ldc% lreg ) THEN
      jglat = ldc%glat(jrow)    ! global index north -> south
    ELSE
      jglat = 1
    END IF

    nrow(1) = 0
    nrow(2) = jrow   
    nrow(3) = jglat

    CALL si1(jrow)

!DIR$ CONCURRENT
    q     (1:nproma,:,jrow)   =  qm1(1:nproma,:,jrow)
!DIR$ CONCURRENT
    xl    (1:nproma,:,jrow)   =  xlm1(1:nproma,:,jrow) 
!DIR$ CONCURRENT
    xi    (1:nproma,:,jrow)   =  xim1(1:nproma,:,jrow) 
!DIR$ CONCURRENT
    xt    (1:nproma,:,:,jrow) =  xtm1(1:nproma,:,:,jrow)
! mz_pj_20060926-
  END DO

! mz_pj_20030930+
    IF (ntrac_a > 0)   xt_a(:,:,:,:) =  xtm1_a(:,:,:,:)
! mz_pj_20030930-
!!$    ! op_sb_20191007+
!!$    IF (ntrac_cl > 0)   xt_c(:,:,:,:) =  xtm1_c(:,:,:,:)
!!$    ! op_sb_20191007-



  CALL test_scan_buffer ('after end of final subscan')

!-- 3.5 Direct fast *fourier transforms

  IF (ltdiag) CALL DIAG_fftd

  CALL gridpoint_to_fourier 

  CALL fftd

!-- 3.6 Semi implicit adjustment (part 2)

  CALL si2

! second part of tendency diagnostics called after SI2

  IF (ltdiag) CALL DIAG_SpecTrans

  CALL fourier_to_legendre

!-- 3.8 Compute contributions to symmetric and
!       antisymmetric *fourier components.

  CALL sym1
!-- 4. Direct *Legendre transforms

  CALL ltd

!-- Transposition Legendre -> spectral

  CALL legendre_to_spectral  

!-- 5. Complete the scans

!-- 5.1 Release space

  rnmd(:) = 0.0_dp ! Legendre fields

!-- 5.2 Complete statistics

  CALL maxwind(ulz,vmaxz)

# 889


!$OMP PARALLEL
!$OMP WORKSHARE
!DIR$ CONCURRENT
  vom1(:,:,:)   = vof(:,:,:)  
!DIR$ CONCURRENT
  dm1(:,:,:)    = df(:,:,:)   
!DIR$ CONCURRENT
  tm1(:,:,:)    = tf(:,:,:) 
  dtlm1(:,:,:)  = dtl(:,:,:)
  dtmm1(:,:,:)  = dtm(:,:,:)  
!DIR$ CONCURRENT
  alpsm1(:,:)   = alpsf(:,:)
  dalpslm1(:,:) = dalpsl(:,:)
  dalpsmm1(:,:) = dalpsm(:,:)  
!DIR$ CONCURRENT
  qm1(:,:,:)    = qf(:,:,:)   
!DIR$ CONCURRENT
  xlm1(:,:,:)   = xlf(:,:,:)   
!DIR$ CONCURRENT
  xim1(:,:,:)   = xif(:,:,:)   
# 914

!$OMP END WORKSHARE
!$OMP END PARALLEL
! mz_ak_20040512+
  DO jt = 1, ntrac
     IF (ti_gp(jt)%tp%meta%cask_i(I_integrate) == ON) &
          xtm1(:,:,jt,:) = xtf(:,:,jt,:)
  END DO
! mz_ak_20040512-
  DO jt = 1, ntrac_a
     IF (ti_lg(jt)%tp%meta%cask_i(I_integrate) == ON) &
          xtm1_a(:,:,jt,:) = xtf_a(:,:,jt,:) ! mz_pj_20030930
  END DO
!$OMP PARALLEL
!$OMP WORKSHARE


!DIR$ CONCURRENT
  um1(:,:,:)    = uf(:,:,:)
!DIR$ CONCURRENT
  vm1(:,:,:)    = vf(:,:,:)
!DIR$ CONCURRENT
  dudlm1(:,:,:) = dudlf(:,:,:)
!DIR$ CONCURRENT
  dvdlm1(:,:,:) = dvdlf(:,:,:)
!$OMP END WORKSHARE
!$OMP END PARALLEL

!!$#ifdef 1
!!$!mz_pj_20040326+
!!$! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$  CALL messy_global_end
!!$! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!$!mz_pj_20040326-
!!$#endif

END SUBROUTINE scan1
