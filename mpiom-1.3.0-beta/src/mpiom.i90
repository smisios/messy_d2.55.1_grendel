# 1 "mpiom.f90"
     PROGRAM MPIOM   
!
!    MPIOM
!
!     Version:
!     ---------
!     $URL: http://svn.zmaw.de/svn/mpiom/tags/mpiom-1.3.0-beta/src/mpiom.f90 $
!     $Rev: 260 $
!
!    VERSION OF THE HOPE OGCM ON C-GRID
!
!    DEVELOPED BY MAIER-REIMER TILL 1997
!
!    VERSION OF UWE MIKOLAJEWICZ,JOHANN JUNGCLAUS AND HELMUTH HAAK, 12/99
!    INCLUDES CONFORMAL MAPPING
!
!    MODIFIED :
!    ---------
!   HOPS65 : CREATED JULI 25, 2000  H. HAAK, J. JUNGCLAUS
!   HOPS67 : CREATED  NOV 09, 2000  H. HAAK, J. JUNGCLAUS, U.MIKOLAJEWICZ
!   HOPS68 : CREATED JUNE 20, 2001  H. HAAK, J. JUNGCLAUS, U.MIKOLAJEWICZ
!                        Nov. 2001  O. Boeringer  - TRANSFER TO FORTRAN90
!                                   S. Legutke    - interface to HAMOCC5
!   HOPS69 : CREATED   JAN 5, 2002  H. HAAK, J. JUNGCLAUS, U.MIKOLAJEWICZ
!   MPI-OM :           JAN 14 2003  S.Legutke     - created mo_couple.F90
!   MPI-OM :           JUN 03 2003  J.Jungclaus   - update GIRIV, RELTEM, ZOCORR
!*************************************************************************
!
!
!                       MP MPIOM
!                      SBR BELEG
!                          BODEN
!                          CORIOL
!                          ITPREP
!                            !
!                 !  --->  THERMODYNAMIC FORCING
!                 !        WIND FORCING
!      TIME       !        DECOMPOSITION INTO BAROTROPIC AND BAROCLINIC FIELD
!      STEPPING   !        BAROTROPIC SYSTEM
!                 !        BAROCLINIC SYSTEM
!                 !        MOMENTUM ADVECTION
!                 !        TRACER ADVECTION
!                 !        TRACER DIFFUSION
!                 !        MOMENTUM DIFFUSION
!                 ! <---     !
!                            !
!                          OUTPUT-ROUTINES

!          ------------------------------
! NUMBER OF VERTICAL LAYERS IS KE.
!
!************************************************************
! PARAMETER :  IE   NUMBER OF GRID POINTS IN X
!              JE                            Y
!              KE                            Z
!              KBB=NMAX,ILL=MATR MUST BE SET BY USER!!!
!
! SOME IMPORTANT VARIABLES AND FIELDS :
!             DT        TIME STEP
!             TIESTU    DEPTH OF HORIZONTAL VELOCITY POINTS
!             TIESTW    DEPTH OF VERTICAL VELOCITY POINTS
!             ZO        SEA SURFACE ELEVATION
!             AMSUE/O   LAND/SEA-MASK FOR VECTORFIELD (LAND=0/SEA=1)
!             WETO                    FOR SCALARFIELD       "
!             UKO       ZONAL VELOCITY COMPONENT
!             VKE       MERIDIONAL "       "
!             WO        VERTICAL VELOCITY COMPONENT
!             THO       TEMPERATURE
!             SAO       SALINITY
!             PO        PRESSURE
!             TXO       ZONAL WIND STRESS
!             TYE       MERIDIONAL WIND STRESS
!             AVO       VARIABLE VERTICAL EDDY VISCOSITY
!                       (DEFINED ON SCALAR POINTS!!)
!             DVO       VARIABLE VERTICAL EDDY DIFFUSIVITY
!
!
! E=MERIDIONAL VELOCITY POINTS, O=ZONAL VELOCITY POINTS/SCALAR POINTS
!***********************************************************************
!                                                                      *
!UWE  AKTUALISIEREN!!!!!!!!!!!!!!!!
!
!     DATA SETS AND FORTRAN CHANNEL NUMBER CODING                      *
!                                                                      *
!     UNIT NO.   NAME     DESCRIPTION                      LOCATION    *
!
!HH    IO_IN_Z370 Z37000  RESTART-INFORMATION   MPIOM.F90,SBR AUFR,SBR AUFW
!HH    IO_IN_Z380 Z38000  RESTART-INFORMATION   MPIOM.F90,SBR AUFR,SBR AUFW
!HH    IO_IN_INIT INITEM  TEMPERATURE LEVITUS          MPIOM.F90,SBR LEVIRE
!HH    IO_IN_INIS INISAL  SALINITY LEVITUS             MPIOM.F90,SBR LEVIRE
!HH    IO_IN_SURS SURSAL  SEA SURFACE SALINITY LEVITUS MPIOM.F90,SBR LEVIRE
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!
      USE MO_PARAM1
      USE MO_MPI
      USE MO_PARALLEL
      USE MO_COMMO1
      USE MO_LEVITUS
      USE MO_COMMOAU1
      USE MO_COMMOAU2
      USE MO_COMMOAU3
      USE MO_DIAGNOSIS
      USE MO_OCTHER
      USE MO_OCICE  
      USE MO_TRO


# 112

     USE MO_OMIP



# 119

 
# 123


      USE MO_ADPO
      USE MO_COMMOBBL

      USE MO_MEAN

      USE MO_ELICOM
      USE MO_PARA2

      USE MO_UNITS
      USE MO_OCECTLCOM
      USE MO_OCTDIFF

# 144


# 150


# 169

      
!     USE MO_OCECTL        module removed, source included below
!
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!     DECLARATIONS
      INTEGER*8 IDATE,III
      INTEGER NACTYEAR
      REAL ABACK,CAULAPTS,CAULAPUV,CRELSAL,CRELTEM,CWT,DBACK,GFDL_DIFF
      REAL PIBOG,RRELSAL,RRELTEM,DIST
      REAL AWERT, DDPOMAX, DDPOMIN, EWERT


      REAL CDZW(500)    
 
      INTEGER I,ICONVA,IWIRB,J,K,M,N,NANF,NDTDAY,ENDDAY
      INTEGER ICOU,IJJU,JMANF,JMEND,JMM,JMMM,LDTRUN
      INTEGER IERR, LDTDAY, LEN_FEB, LMON1, LMON2, LREAD
      INTEGER LREADMAX, MONMON, NACYEAR, NDTYEAR, IMAL
      INTEGER L,IREADC
      REAL*8 ttts, tttr, ttt



  REAL :: zwtime,zutime,zstime, zrtime

!  External functions
  REAL, EXTERNAL :: util_walltime
  INTEGER, EXTERNAL :: util_cputime




! OtB  cannot use variables in more than one module
! ---------------------------------------------------------------------
!
!*    *NAMELIST* *OCECTL*   - Defines namelist parameters.
!                           - included in *MPIOM*.
!
!*     VARIABLE  TYPE        PURPOSE.
!      --------  ----        --------
!      *DT*      *REAL*      Ocean time step in sec
!
! ---------------------------------------------------------------------
!
      NAMELIST /OCEDIM/ IE_G,JE_G,KE     !declared in mo_param1

      NAMELIST /OCECTL/                                                &
              DT                                                       &
             ,CAULAPTS, CAULAPUV, CAH00, AUS                           &
             ,AV0,DV0,CWT,CSTABEPS,DBACK,ABACK,CRELSAL,CRELTEM         &
             ,ICONVA, IWIRB                                            &
             ,RRELTEM, RRELSAL                                         &
             ,CDVOCON,CAVOCON                                          &
             ,IOCAD,isnflg                                             &
             ,H0, HMIN, ARMIN, ARMAX, HSNTOICE, SICTHMIN, SICE         &
             ,D3                                                       &
             ,IAUFR, IAUFW                                             &
             ,ISTART,I3DREST                                           &
             ,NYEARS, NMONTS, NDAYS, IMEAN, LY_END, LY_START,LM_START  &
             ,EXPTID,ICONTRO,IOASISFLUX,imocdiag                       &
             ,LFORCEDIAG,LHFLDIAG,LCONVDIAG,LDIFFDIAG,LGMDIAG,LGRIDINFO &
             ,LCALCDIFI

      NAMELIST /OCEDZW/ CDZW

      NAMELIST /NPROCS/ nprocx, nprocy ! declared in mo_parallel

# 244





! Initialize wallclock timer
  zwtime = util_walltime()


!     Initialize MPI

      CALL p_start

!     SPECIFY LOGICAL I/O UNITS

      CALL SETUNITS
!  OPEN STD OUT FILE
!  This is needed for the MPI version since we do not want
!  the output of all processors intermixed (and basically
!  we want only the ouput of processor 0)

      IF (io_stdout > 0) THEN
        CALL OPEN_STDOUT(io_stdout,'oceout')
      ENDIF

!     Open input file and read the number of processors along
!     x- and y-direction

      IF(p_pe==p_io) THEN
        OPEN(IO_IN_OCTL,FILE='OCECTL.nml',STATUS='UNKNOWN',                 &
     &          ACCESS='SEQUENTIAL',FORM='FORMATTED')

        READ(IO_IN_OCTL,OCEDIM)   ! read dimensions
!        write(0,*)'read dimensions'
        READ(IO_IN_OCTL,NPROCS)
!       write(0,*)'read decomposition'
      ENDIF

      CALL p_bcast(ie_g,p_io)
      CALL p_bcast(je_g,p_io)
      CALL p_bcast(ke,p_io)

!     Domain decomposition, setting local IE and JE
!       write(0,*)'vor deco'

      CALL p_deco
!       write(0,*)'nach deco',ie_g,je_g,ke,ie,je


!     Set some dependent parameters and allocate arrays

      CALL set_param1
      CALL alloc_mem_commo1
      CALL alloc_mem_octdiff
      CALL alloc_mem_commoau2
      CALL alloc_mem_commoau3
      CALL alloc_mem_diag

      CALL alloc_mem_dilcor



# 308


!#ifdef CONVDIAG
!      CALL alloc_mem_commconv
!#endif /*CONVDIAG*/

# 319

!    write(0,*)'vor elicom'

      CALL alloc_mem_elicom
      CALL alloc_mem_para2

# 327

# 331

!      write(0,*)'vor beleg'

      ZERO=0.0
      CALL BELEG_ZERO


!  DEFAULT LENGTH OF INTEGRATION

!      write(0,*)'vor namelist'


      NYEARS=0
      NMONTS=1


      NANF=0
      NNNDT = 0
      NDAYS = 0
      DH = 0.
      AH = 0.
      FOUR=4.0
      TWO=2.
      ONE=1.0

      HALF=0.5
      FOURTH=0.25
      EIGHTH=0.125
      TENM4=1.E-4
      ALMZER=1.E-19

      monlen(:) = (/ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 /)

# 366


# 370


      WINTUR(1)=0.
      WINTUR(2)=1.E-3
      DO K=3,KEP
         WINTUR(K)=0.3*WINTUR(K-1)
      ENDDO

!     DZwW(K) DECOFTES THE THICKNESS OF LAYER K IN METERS
!     SUM OF DZW(1-KE) IS THE BOTTOM OF THE MODEL, I.E. SOLID GROUND !!!
!     DZ(K) DECOFTES THE DISTANCE BETWEEN VECTOR POINTS BUT WILL BE
!     COMPUTED IN SBR BODEN FOR CONSISTENCY WITH W-POINTS
      DO K=1,KE
         SAF(K)=34.8
         TAF(K)=1.
         DZW(K)=0.
      ENDDO  
!
!----------------------------------------------------------------------
! DEFAULT PARAMETER SETTINGS - CAN BE OVERWRITEN BY THE NAMELIST
! ISTART :: START OPTIONS
! ISTART == 0: COMPLETELY NEW SETUP,
!              topography read from anta and written to topo (!!! WARNING !!!)
!              start from climatology
! ISTART == 1: new run, topography read from topo
!              start from horizontally uniform ts-profile (taf,saf)
! ISTART == 2: new run, topography read from topo
!              start from climatology
! ISTART == 3: continuing run (default)
         ISTART =3
!
! I3DREST OPTIONS FOR 3-D RESTORING
! I3DREST == 0: NO RESTORINg (DEFAULT)
! I3DREST == 1: RESTORING to annual climatology
! I3DREST == 2: RESTORING to monthly climatology
         I3DREST=0
!--------------------------------------------------------------------
!  TRACER ADVECTION ROUTINES : SEVERAL OPTIONS
!  IOCAD ==  1: UPWIND
!  IOCAD ==  2: not used
!  IOCAD ==  3: ADPO
!  IOCAD ==  4: ADPO + SLOPECON_ADPO
!  IOCAD ==  5: ADFS
!  IOCAD ==  6: not yet --> QUICK
!  IOCAD ==  7: mot yet --> QUICK2

         IOCAD=4

        ICONTRO=0

!HH    DEFAULT TIME STEPS
         DT=1800.

!UWE   CONSTANTS FOR BIHARMONIC DIFFUSION
         CAULAPTS=0.0002

!UWE   CONSTANTS FOR HARMONIC DIFFUSION
         CAH00=0.


         CAULAPTS=0.


!UWE   CONSTANTS FOR BIHARMONIC FRICTION
         CAULAPUV=0.0045

!UWE   CONSTANTS FOR HARMONIC FRICTION
         AUS=3.E-6


         CAH00=1000.


!HH    CONSTANT FOR DIFFUSION IN OCTHER
        DV0=0.5E-2
        AV0=0.5E-2
        CDVOCON=20.
        CAVOCON=0.

!HH    CONSTANT FOR WINDMIXING IN OCTHER
        CWT=0.5E-3
        CSTABEPS=0.05

!HH    BACKGROUNDDIFFUSION
        ABACK=5.E-5
        DBACK=5.E-5

!HH    DEFAULT MEAN OUTPUT
       IMEAN=2

!HH    RELAXATION TIME SALINITY
        CRELSAL = 3.E-7

!HH    RELAXATION TIME TEMERATURE
        CRELTEM = 0.

!JJ    DEFAULT END OF RUN IN YEAR
       LY_END=5000

!JJ    DEFAULT OFFSET FOR YEAR COUNTER (NEG. VALUE == NO ACTION TAKEN)
       LY_START=-999
       LM_START=-999
!----------------------------------------------------------------------
!     ICONVA : 1   WITH CONVECTIVE ADJUSTMENT
!              0    NO      "          "
      ICONVA=1
!-------------------------------------------------------
!     IWIRB  : 1   COMPUTE VARIABLE EDDY VISCOSITY
!              0   CONSTANT EDDY VISCOSITY
      IWIRB=1
!----------------------------------------------------------------------
! SWITCH FOR RESPECTIVE RESTART FILES
!
      IFLAG=1

!----------------------------------------------------------------------

!  SWITCH FOR WRITING OASIS COUPLED FLUXES

    IOASISFLUX=0
    IMOCDIAG=0

    LGMDIAG=.FALSE.
    LFORCEDIAG=.FALSE.
    LHFLDIAG=.FALSE.
    LCONVDIAG=.FALSE.
    LDIFFDIAG=.FALSE.
    LGRIDINFO=.FALSE.
    LCALCDIFI=.FALSE.

!  READ OCEAN NAMELIST

      IF(p_pe==p_io) THEN

!        write(0,*)'vor ocectl'
        READ(IO_IN_OCTL,OCECTL)
!        Write(0,*)'after ocectl'
        READ(IO_IN_OCTL,OCEDZW)
!      Write(0,*)'after ocedzw'
        CLOSE(IO_IN_OCTL)

      ENDIF


      if (imean.eq.0) then

      IF ( LGMDIAG ) Write(0,*)'imean = 0 => LGMDIAG disabled'
        LGMDIAG=.FALSE.
      IF ( LFORCEDIAG ) Write(0,*)'imean = 0 => LFORCEDIAG disabled'
        LFORCEDIAG=.FALSE.
      IF ( LHFLDIAG ) Write(0,*)'imean = 0 => LHFLDIAG disabled'
      LHFLDIAG=.FALSE.
      IF ( LCONVDIAG ) Write(0,*)'imean = 0 => LCONVDIAG disabled'
      LCONVDIAG=.FALSE.
      IF ( LDIFFDIAG ) Write(0,*)'imean = 0 => LDIFFDIAG disabled'
      LDIFFDIAG=.FALSE.
        IF ( LGRIDINFO ) Write(0,*)'imean = 0 => LGRIDINFO disabled'
      LGRIDINFO=.FALSE.
        IF ( LCALCDIFI ) Write(0,*)'imean = 0 => LCALCDIFI disabled'
      LCALCDIFI=.FALSE.
      endif


      CALL p_bcast(DT,p_io)
      CALL p_bcast(CAULAPTS,p_io)
      CALL p_bcast(CAULAPUV,p_io)
      CALL p_bcast(CAH00,p_io)
      CALL p_bcast(AUS,p_io)
      CALL p_bcast(AV0,p_io)
      CALL p_bcast(DV0,p_io)
      CALL p_bcast(CWT,p_io)
      CALL p_bcast(CSTABEPS,p_io)
      CALL p_bcast(DBACK,p_io)
      CALL p_bcast(ABACK,p_io)
      CALL p_bcast(CRELSAL,p_io)
      CALL p_bcast(CRELTEM,p_io)
      CALL p_bcast(ICONVA,p_io)
      CALL p_bcast(IWIRB,p_io)
      CALL p_bcast(RRELTEM,p_io)
      CALL p_bcast(RRELSAL,p_io)
      CALL p_bcast(CDVOCON,p_io)
      CALL p_bcast(CAVOCON,p_io)
      CALL p_bcast(ISNFLG,p_io)
      CALL p_bcast(IOCAD,p_io)
      CALL p_bcast(ICONTRO,p_io)
      CALL p_bcast(H0,p_io)
      CALL p_bcast(HMIN,p_io)
      CALL p_bcast(ARMIN,p_io)
      CALL p_bcast(ARMAX,p_io)
      CALL p_bcast(HSNTOICE,p_io)
      CALL p_bcast(SICTHMIN,p_io)
      CALL p_bcast(SICE,p_io)
      CALL p_bcast(D3,p_io)
      CALL p_bcast(IAUFR,p_io)
      CALL p_bcast(IAUFW,p_io)
      CALL p_bcast(NYEARS,p_io)
      CALL p_bcast(NMONTS,p_io)
      CALL p_bcast(NDAYS,p_io)
      CALL p_bcast(IMEAN,p_io)
      CALL p_bcast(LY_END,p_io)
      CALL p_bcast(LY_START,p_io)
      CALL p_bcast(LM_START,p_io)
      CALL p_bcast(EXPTID,p_io)
      CALL p_bcast(ISTART,p_io)
      CALL p_bcast(I3DREST,p_io)
      CALL p_bcast(IOASISFLUX,p_io)
      CALL p_bcast(IMOCDIAG,p_io)
      CALL p_bcast(LFORCEDIAG,p_io)
      CALL p_bcast(LHFLDIAG,p_io)
      CALL p_bcast(LCONVDIAG,p_io)
      CALL p_bcast(LDIFFDIAG,p_io)
      CALL p_bcast(LGMDIAG,p_io)
      CALL p_bcast(LGRIDINFO,p_io)
      CALL p_bcast(LCALCDIFI,p_io)

      do k=1,ke
              DZW(k)=CDZW(k)
!         write(0,*) k,cdzw(k),dzw(k)
 
      enddo

      CALL p_bcast(dzw,p_io)

      DTI=1./DT
      NDTDAY=NINT(86400./DT)

! Write final namelist parameters
!
      WRITE(IO_STDOUT,*)' SECONDS PER TIMESTEP   (DT): ',DT
      WRITE(IO_STDOUT,*)' TIME STEPS PER DAY (NDTDAY): ',NDTDAY
      WRITE(IO_STDOUT,*)'                     (IOCAD): ',IOCAD
      WRITE(IO_STDOUT,*)'                  (CAULAPUV): ',CAULAPUV
      WRITE(IO_STDOUT,*)'                  (CAULAPTS): ',CAULAPTS
      WRITE(IO_STDOUT,*)'                       (AUS): ',AUS
      WRITE(IO_STDOUT,*)'                     (CAH00): ',CAH00
      WRITE(IO_STDOUT,*)'                       (AV0): ',AV0
      WRITE(IO_STDOUT,*)'                       (DV0): ',DV0
      WRITE(IO_STDOUT,*)'                       (CWT): ',CWT
      WRITE(IO_STDOUT,*)'                  (CSTABEPS): ',CSTABEPS
      WRITE(IO_STDOUT,*)'                     (DBACK): ',DBACK
      WRITE(IO_STDOUT,*)'                     (ABACK): ',ABACK
      WRITE(IO_STDOUT,*)'                   (CRELSAL): ',CRELSAL
      WRITE(IO_STDOUT,*)'                   (CRELTEM): ',CRELTEM
      WRITE(IO_STDOUT,*)'                   (CDVOCON): ',CDVOCON
      WRITE(IO_STDOUT,*)'                   (CAVOCON): ',CAVOCON
      WRITE(IO_STDOUT,*)'                     (IMEAN): ',IMEAN
      WRITE(IO_STDOUT,*)'                  (LY_START): ',LY_START
      WRITE(IO_STDOUT,*)'                  (LM_START): ',LM_START
      WRITE(IO_STDOUT,*)'                    (LY_END): ',LY_END
      WRITE(IO_STDOUT,*)'                    (ISTART): ',ISTART
      WRITE(IO_STDOUT,*)'                   (I3DREST): ',I3DREST
      WRITE(IO_STDOUT,*)'                   (ICONTRO): ',ICONTRO
      WRITE(IO_STDOUT,*)'                (IOASISFLUX): ',IOASISFLUX
      WRITE(IO_STDOUT,*)'                  (IMOCDIAG): ',IMOCDIAG
      WRITE(IO_STDOUT,*)'                   (LGMDIAG): ',LGMDIAG
      WRITE(IO_STDOUT,*)'                (LFORCEDIAG): ',LFORCEDIAG
      WRITE(IO_STDOUT,*)'                  (LHFLDIAG): ',LHFLDIAG
      WRITE(IO_STDOUT,*)'                 (LDIFFDIAG): ',LDIFFDIAG
      WRITE(IO_STDOUT,*)'                 (LCONVDIAG): ',LCONVDIAG
      WRITE(IO_STDOUT,*)'                 (LGRIDINFO): ',LGRIDINFO
      WRITE(IO_STDOUT,*)'                 (LCALCDIFI): ',LCALCDIFI

      IF (ISTART .LT. 0 .OR. ISTART .GT. 3)                              &
          WRITE(IO_STDOUT,*)'ISTART NOT SUPPORTED!!!!!'
      IF (I3DREST .LT. 0 .OR. I3DREST .GT. 2)                            &
          WRITE(IO_STDOUT,*)'I3DREST NOT SUPPORTED!!!!!'     

      WRITE(IO_STDOUT,*)'THIS JOB WILL TRY TO INTEGRATE '               &
                        ,NYEARS,' YEARS AND '                           &
                        ,NMONTS,' MONTHS AND'                           &
                        ,NDAYS,'DAYS'




      IF (I3DREST .GT. 0 .OR. ISTART .LT. 3) THEN
       CALL init_levitus(ie,je,ke)
      ENDIF


!  DEFAULT ...
       IAUFR=1
       IAUFW=1
      IF (ISTART .LT. 3) IAUFR=0

      AULAPTS=CAULAPTS*DT/3600.
      AULAPUV=CAULAPUV*DT/3600.
      AH00=CAH00/4.E5
      WT=CWT/(6.**3)

!HH   CHECK LAYER THICKNESS
      DO K=1,KE
        IF(DZW(K).EQ.0.) THEN
          WRITE(IO_STDOUT,*)' LAYER: ',K,' THICKNESS IS ZERO !!!'
          CALL ABSTURZ 
        ELSE
          WRITE(IO_STDOUT,*) K, ' LAYERTHICKNESS    (DZW): ',DZW(K)
        ENDIF
      ENDDO


!HH   BACKGROUNDDIFFUSION
      DO K=1,KEP
        ABACKV(K) = ABACK
        DBACKV(K) = DBACK 
      ENDDO

      TIESTW(1) = 0.
      DO K=1,KE
      TIESTW(K+1)  = TIESTW(K) + DZW(K)
      ENDDO
      PI=4.*ATAN(1.)
      PIBOG=180./PI

# 693


      DO K=1,KEP
         GFDL_DIFF = 1.E-4 *                                            &
     &            (0.8 + 1.05/PI*ATAN(4.5*1.E-3*(TIESTW(K)-2500.)))
# 700

       ENDDO

# 705

       DO K=1,KEP
         WRITE(IO_STDOUT,6002)'BACKGROUND DIFFUSIVITY AT '              &
     &                        ,INT(TIESTW(K))                           &
     &         ,'M : HOPE : ',DBACKV(K),' GFDL : ',GFDL_DIFF
         WRITE(IO_STDOUT,6002)'BACKGROUND VISCOSITY AT ',INT(TIESTW(K)) &
     &         ,'M : HOPE : ',ABACKV(K)
       ENDDO

 6002  FORMAT(1X,A27,I5,A10,E12.3,A8,E12.3)

!HH    RELAXATION TIME SALINITY
!      RELSAL = CRELSAL*20./DZW(1)
      RELSAL = CRELSAL
      IF (RELSAL.GT. ALMZER) THEN 
!         WRITE(IO_STDOUT,26668)1./(RELSAL*24.*3600.)
         if (p_pe==p_io) then
          WRITE(0,*) 'RELAXATION DZW(1) [m]  =',DZW(1)
          WRITE(0,*)' RELAXATION TIME [DAYS] =',1./(RELSAL*24.*3600.)
          WRITE(0,*)' PISTON VELOCITY [m/s]  =',DZW(1)*(RELSAL)
          WRITE(0,*)' RELAXATION TIME (relative to 20m) [DAYS] =',1./(RELSAL*24.*3600.*DZW(1)/20.)
       endif
      ELSE
         if (p_pe==p_io) then
            WRITE(IO_STDOUT,*) 'SSS relaxation switched off !!'
         endif
      ENDIF

!26668 FORMAT('  RELAXATION TIME SALINITY COUPLING : ',F10.2,' DAYS')
!HH    RELAXATION TIME TEMPERATURE
!      RELTEM = CRELTEM*20./DZW(1)
      RELTEM = CRELTEM
      IF (reltem.GT. ALMZER) THEN 
!         WRITE(IO_STDOUT,26669)1./(RELTEM*24.*3600.)
       if (p_pe==p_io) then
          WRITE(IO_STDOUT,*)'  RELAXATION TIME TEMPEARTURE COUPLING : '&
              ,DZW(1),' m /',(RELTEM*24.*3600.),' DAYS'
       endif
     ELSE
        if (p_pe==p_io) then
           WRITE(IO_STDOUT,*) 'SST relaxation switched off !!'
        endif
      ENDIF
!26669 FORMAT('  RELAXATION TIME SST COUPLING : ',F10.2,' DAYS')


!-----------------------------------------------------------------------

      IF(IOCAD.EQ.3.OR.IOCAD.EQ.4)THEN
         CALL alloc_mem_adpo
      ENDIF

      IF(IOCAD.EQ.4)THEN
         CALL alloc_mem_commobbl
      ENDIF

!    write(0,*)'vor mean'

      if(imean.ne.0) then
         CALL alloc_mem_mean
      endif


   
# 774


!----------------------------------------------------------------------
! OPEN FILES
      IF(p_pe==p_io) THEN
        OPEN(IO_IN_ARCG,FILE='arcgri',                                  &
     &          ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
!     &                  convert = 'BIG_ENDIAN')
        OPEN(IO_IN_INIT,FILE='INITEM',STATUS='UNKNOWN',                 &
     &          ACCESS='SEQUENTIAL',FORM='UNFORMATTED')                 
!     &          convert = 'BIG_ENDIAN')
        OPEN(IO_IN_INIS,FILE='INISAL',STATUS='UNKNOWN',                 &
     &          ACCESS='SEQUENTIAL',FORM='UNFORMATTED')                 
!     &          convert = 'BIG_ENDIAN')
        OPEN(IO_IN_SURS,FILE='SURSAL',STATUS='UNKNOWN',                 &
     &          ACCESS='SEQUENTIAL',FORM='UNFORMATTED')                 
!     &          convert = 'BIG_ENDIAN')
        IF (RELTEM .GT. ALMZER) THEN
          OPEN(IO_IN_SURT,FILE='SURTEM',STATUS='UNKNOWN',               &
     &            ACCESS='SEQUENTIAL',FORM='UNFORMATTED')               
!     &            convert = 'BIG_ENDIAN')
        ENDIF

# 801



# 808

      WRITE(IO_STDOUT,*) 'open omip'
      CALL open_omip





# 821

      ENDIF ! p_pe == p_io

!-------------------------------------------------------------------

!     DU/DT - F*V = -G*( STABN* (DZ/DX)(NEW) + STABO* (DZ/DX)(OLD) )

!     DZ/DT = H*( CONN* (DU/DX)(NEW) + CONO* (DU/DX)(OLD) + ... )

      STABN=0.6
      STABO=1.-STABN

      CONN=0.50
      CONO=1.-CONN

      WRITE(IO_STDOUT,*)' STABN = ',STABN,' CONN = ',CONN
!
!-------------------------------------------------------------------
!  OMEGA  :  ANGULAR VELOCITY OF OUR NICE BLUE PLANET
!  RADIUS :  RADIUS OF THE ABOVE MENTIONED PLANET
!  G      :  GRAVITATIONAL ACCELERATION ( CONSTANT 9.81 M/S**2
!                TO ACCOUNT FOR THE EXISTENCE OF MINI BLACK HOLES )
!  ROCP   :  HEAT CAPACITY PER CUBICMETER
!  ROCD   :  WIND STRESS DRAG COEFFICIENT
!------------------------------------------------------------------
      PI=4.*ATAN(1.)
      OMEGA=7.292E-5
      RADIUS=6371.E+3
      G=9.81
      GHN=G*STABN
      GHO=G*STABO
      ROCP=4.E06
      ROCD=1.2*1.5E-3
!-------------------------------------------------------------------
! PARAMETER ICE MODEL

      ACLO(:,:)=0.7
      PAO(:,:)=101300.
      RPRECO(:,:)=0.0
      FRSE(:,:)=0.0

      ISNFLG=1

      ALBI=0.75
      ALBM=0.66
      ALBW=0.10
      ALBSN=0.85
      ALBSNM=0.75
# 873



!SJM TUNE ALBEDOS FOR OMIP WITH BERYLIAND
      ALBI=0.75    !ICE < 0
      ALBM=0.70    !ICE > 0
      ALBW=0.10    !WATER
      ALBSN=0.85   !SNOW < 0
      ALBSNM=0.70  !SNOW > 0

# 890

# 896

      TMELT=273.16
      TFREZ=-1.9
      CC=4.2E6
      CW=0.0045
      CLO=3.02E8
      CLB=2.70E8
      RHOAIR=1.3E+00
      RHOWAT=1.025E+03
      RHOICE=0.91E+03
      RHOSNO=0.33E+03
      RHOICWA=RHOICE/RHOWAT
      RHOSNWA=RHOSNO/RHOWAT
      RHOSNIC=RHOSNO/RHOICE
      CON=2.1656
      CONSN=0.31
      H0=0.5
      ARMIN=0.15
      ARMAX=1.0
      HMIN=0.05
!UWE  MAXIMUM ICE THICKNESS FOR SNOW-->ICE CONVERSION
!      HSNTOICE = 17.
       HSNTOICE = 0.45 * DZW(1)
!UWE  MINIMUM ICE THICKNESS IN NEW ICE GROWTH
      SICTHMIN=0.5
!
      VAPL=2.5E6
      SUBL=2.834E6
      SICE=5.0
      D3=5.5E-08
!
!JJ OLD VALUES UP TO HOPS 62!
      D1=RHOAIR*1004.*1.75E-3
      D2I=RHOAIR*SUBL*1.75E-3
      D2W=RHOAIR*VAPL*1.75E-3

# 937

# 942


      D1=RHOAIR*1004.67
      D2I=RHOAIR*SUBL
      D2W=RHOAIR*VAPL


      TFREEZ=TFREZ
      ENTMEL=320.E6
      SICHEC=2.
      HICCE=2.
      HICCP=20.
      HTH00=0.5
      STEBOL=5.67E-8

      N=JTO
      N1=N-1
      N2=N-2
      N3=N-3
      N4=N-4

      M=IE
      M1=M-1
      M2=M-2
      M3=M-3
      M4=M-4

      KB=KBB
      KM=KB+1
      KBM=KB+KM

      DEUTO(:,:)=0.
      DEUTE(:,:)=0.
      DEPTO(:,:)=0.

      IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
      CALL read_slice(IO_IN_ARCG,DEUTO)

      IF (ISTART .EQ. 0) THEN

      CALL bounds_exch('p',DEUTO,'mpiom 10')


         DO J=1,JE
            DO I=1,IE
               DEPTO(I,J)=DEUTO(I,J)
            ENDDO
         ENDDO


         DO I=1,IE

            IF(have_g_js) THEN
               DEPTO(I,1)=0.
               DEPTO(I,2)=0.
            ENDIF

            IF(have_g_je) THEN
               DEPTO(I,JE)=0.
               DEPTO(I,JE1)=0.
            ENDIF
         ENDDO


       DO 8261 J=2,JE1
       DO 8261 I=2,IE1
          DEUTO(I,J)=DEPTO(I,J)
          IF(DEPTO(I,J).LT.1.) GO TO 8261
          IF(DEPTO(I-1,J).LT.1..AND.DEPTO(I+1,J).LT.1.                  &
     &        .AND.DEPTO(I,J-1).LT.1..AND.DEPTO(I,J+1).LT.1.)           &
     &        DEUTO(I,J)=0.
8261   CONTINUE

       CALL bounds_exch('u+',DEUTO,'mpiom 11')


       DO 8262 J=1,JE
       DO 8262 I=1,IE
          DEPTO(I,J)=DEUTO(I,J)
8262   CONTINUE

       ENDIF ! ISTART

       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, DLXP)
       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, DLXU)
       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, DLXV)
       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, DLYP)
       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, DLYU)
       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, DLYV)
       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, FTWOU)
       IF(p_pe==p_io) READ(IO_IN_ARCG) IBLA
       CALL read_slice(IO_IN_ARCG, FTWOV)
       IF(p_pe==p_io) CLOSE(IO_IN_ARCG)




       DLXP(:,:)=MAX(1.,DLXP(:,:))
       DLXU(:,:)=MAX(1.,DLXU(:,:))
       DLXV(:,:)=MAX(1.,DLXV(:,:))
       DLYP(:,:)=MAX(1.,DLYP(:,:))
       DLYU(:,:)=MAX(1.,DLYU(:,:))
       DLYV(:,:)=MAX(1.,DLYV(:,:))

       CALL bounds_exch('v+',DLXV,'mpiom 12')
       CALL bounds_exch('p',DLXP,'mpiom 13')
       CALL bounds_exch('u+',DLXU,'mpiom 14')
       CALL bounds_exch('p',DLYP,'mpiom 15')
       CALL bounds_exch('u+',DLYU,'mpiom 16')
       CALL bounds_exch('v+',DLYV,'mpiom 17')


!SL
!SL GRID DEFORMATION
!SL
       DO J=2,JE1
         DO I=2,IE1
             CURVAV(I,J)=(DLXP(I,J+1)-DLXP(I,J))/(DLYV(I,J)*DLXV(I,J))
         ENDDO
       ENDDO

       CALL bounds_exch('v+',CURVAV,'mpiom 18')


       DO 13788 I=1,IE
          IF(have_g_je) THEN
             CURVAV(I,JE)=CURVAV(I,JE-1)
             DLYP(I,JE)=DLYP(I,JE-1)
             DLYV(I,JE)=DLYV(I,JE-1)
             DLXV(I,JE)=DLXV(I,JE-1)
             DLXP(I,JE)=DLXP(I,JE-1)
             DLXU(I,JE)=DLXU(I,JE-1)
             DLYU(I,JE)=DLYU(I,JE-1)
          ENDIF
13788  CONTINUE
!
      CALL BELEG
!      PRINT*,'nach beleg'
!
      CALL BODEN
!      PRINT*,'nach boden'
!
!-------------------------------------------------------------------
!OtB LMONTS used in LEVIRE but not defined yet
      LMONTS=0
       IF (I3DREST .GT. 0) THEN
! READ 3D LEVITUS DATA FOR USE IN 3D RESTORING
!
!!$      IF(p_pe==p_io) THEN
!!$        REWIND(IO_IN_INIT)
!!$        REWIND(IO_IN_INIS)
!!$      ENDIF
      CALL LEVIRE(-1)
      ENDIF ! I3DREST
!
!-------------------------------------------------------------------
! SPECIFY CORIOLIS PARAMETER ETC.
!
      CALL CORIOL
!
!
! INITIALIZE DIAGNOSTICS
      CALL DIAG_INI                      
!   write(0,*)'nach diag_ini'
!
!-------------------------------------------------------------------
! DIAGNOSTICS : MASKS OF BASINS
!               9 : GLOBAL
!
      IF(p_pe==p_io) OPEN(IO_IN_BGIN,FILE='BEK',FORM='FORMATTED')
!
      DO J=1,JE_G
      DO I=1,IE_G
         IBEK_G(I,J)=9*NINT(WETO_G(I,J,1))
      ENDDO
      ENDDO
      JMMM=(JE_G-1)/120
      IF (ISTART .GT. 0 ) THEN
      IF(p_pe==p_io) THEN
        DO JMM=0,JMMM
        JMANF=1+JMM*120
        JMEND=MIN((JMM+1)*120,JE_G)
        DO I=2,IE_G-1
# 1135

          READ(IO_IN_BGIN,'(I3,2X,120I1)')IJJU,                         &
     &                    (IBEK_G(I,J),J=JMEND,JMANF,-1)

        ENDDO
        ENDDO
      ENDIF
      CALL p_bcast(IBEK_G,p_io)
      ENDIF !ISTART
!
      DO J=1,JE_G
       IBEK_G(1,J)=IBEK_G(IE_G-1,J)
       IBEK_G(IE_G,J)=IBEK_G(2,J)
      ENDDO

      DO J=2,JE_G-1
       DO I=2,IE_G-1
        IBEK_G(I,J)=IBEK_G(I,J)*NINT(WETO_G(I,J,1))
        IF(WETO_G(I,J,1).GT.0.5.AND.IBEK_G(I,J).EQ.0)THEN
        IBEK_G(I,J)=MAX(IBEK_G(I+1,J),IBEK_G(I-1,J),IBEK_G(I,J+1),      &
     &                  IBEK_G(I,J-1))
        ENDIF
       ENDDO
      ENDDO

      IF(p_pe==p_io) THEN
        REWIND(IO_IN_BGIN)
        DO JMM=0,JMMM
        JMANF=1+JMM*120
        JMEND=MIN((JMM+1)*120,JE_G)
        WRITE(IO_STDOUT,*)'IBEK, JM ',JMM,JMEND,JMANF
        DO I=2,IE_G-1
# 1170

          WRITE(IO_IN_BGIN,'(I3,2X,120I1)')I,                           &
     &                     (IBEK_G(I,J),J=JMEND,JMANF,-1)


        ENDDO
        ENDDO
        CLOSE(IO_IN_BGIN)
      ENDIF

      IBEK(:,:) = IBEK_G(p_ioff+1:p_ioff+ie,p_joff+1:p_joff+je)

!-------------------------------------------------------------------

      WRITE(IO_STDOUT,*) 'DZ ', DZ,DI,DZW,TIESTU
      WRITE(IO_STDOUT,*)'WETO:'
      DO JMM=0,JMMM
         JMANF=1+JMM*120
         JMEND=MIN((JMM+1)*120,JE_G)
         WRITE(IO_STDOUT,*)'JMM ',JMM,JMANF,JMEND
         WRITE(IO_STDOUT,6061)0,(MOD(J,10),J=JMEND,JMANF,-1)
         WRITE(IO_STDOUT,*)'        J  <=== '
!         DO I=1,IE_G
!            WRITE(IO_STDOUT,6061)I,(NINT(WETO_G(I,J,1))*MOD(J,10)       &
!                 -10*NINT(WETO_G(I,J,1)-1.),J=JMEND,JMANF,-1)
!         ENDDO
      ENDDO

      DO J=1,JE_G
         ICOU=0
         DO I=2,IE_G-1
            IF(WETO_G(I,J,1).GT.0.5)ICOU=ICOU+1
         ENDDO
            WRITE(IO_STDOUT,*)'ZAEHL : ',J,ICOU
         ENDDO
 6061       FORMAT(I4,1X,120I1)
!            Print*,'nach Zaehl'
!-------------------------------------------------------------------

      IF (ISTART .LT. 3) THEN
         DO K=1,KE
            DO J=1,JE
               DO I=1,IE
                  THO(I,J,K)=TLEVI(I,J,K)
                  SAO(I,J,K)=SLEVI(I,J,K)
               ENDDO
            ENDDO
         ENDDO
     ENDIF !ISTART








     IF(IOCAD.EQ.4)THEN
! PREPARE FOR BOTTOM BOUNDARY PARAMETRIZATIONS
        CALL FINDBOT(KBOT,WETO,IE,JE,KE)
        CALL FINDALFA
!      PRINT*,'nach SLOPECON_ADPO'
     ENDIF

!-------------------------------------------------------------------
!  provide matrix for barotropic mode
!     uwe  add iteration of matrix
!
      IF(ielimi.GE.1) THEN
         CALL trian
      ELSE
         CALL itprep
         CALL trotest2
      ENDIF
!      print*,'nach trotest'
!-------------------------------------------------------------------


    call river_runoff_ini
!      write(0,*)'no river_runoff_ini'

! INCLUDE WRITEOUT OF CPP OPTIONS AND PARAMETER SETTINGS
      CALL CPPOUTPUT
!-----------------------------------------------------------------------
!
!     TIMESTEPPING IS BASED ON 3 LOOPS
!          OUTER LOOP : DO 1000  LYEAR = LYEAR1, LYEAR2
!        1.INNER LOOP : DO 1100  LMONT = 1 OR LMONT1, LMONT2 OR 12
!        2.INNER LOOP : DO 1010  LDAY  = 1,MONLEN(LMONTS)
!        3.INNER LOOP : DO 1001  LDTDAY  = 1,NDTDAY
! ADDITIONAL COUNTERS
!        LYEARS = ACTUAL YEAR
!        LMONTS = ACTUAL MONTH
!        LDAYS  = ACTUAL DAY
!
!     TIME COUNTER ARE :
!               LDT       : TIME STEP COUNTER FOR EXPERIMENT
!               LDTRUN    : TIME STEP COUNTER FOR RUN
!               LDTYEAR   : TIME STEP COUNTER FOR YEAR
!               LDTMONTH  : TIME STEP COUNTER FOR MONTH
!               NDTMONTH  : TIME STEPS IN ACTUAL MONTH
!               NDTDAY  : TIME STEPS PER DAY
      WRITE(IO_STDOUT,*)'START FROM PREVIOUS CALCULATION YES=1/NO=0 : ' &
     &                  ,IAUFR
      WRITE(IO_STDOUT,*)'WRITE RESTART FILE              YES=1/NO=0 : ' &
     &                  ,IAUFW




!
!
!-----------------------------------------------------------------------
!
!     START FROM STATUS LEVITUS OR HORIZONTAL STRATIFICATION
!
!  CALL LEVIRE WITH ARGUMENT =  0 : HORIZONTAL STRATIFICATION
!  CALL LEVIRE WITH ARGUMENT = 13 : 3D STRATIFICATION
!  CALL LEVIRE WITH ARGUMENT = -2 : SURFACE SALINITY



      CALL LEVIRE(-2)
      IF (RELTEM .GT. ALMZER) THEN
      CALL LEVIRE(-3)
      ENDIF

      IF(IAUFR.EQ.0) THEN
         IF (ISTART .EQ. 0) CALL LEVIRE(13)
         IF (ISTART .EQ. 1) CALL LEVIRE(0)
         IF (ISTART .EQ. 2) THEN
         
       CALL LEVIRE(13)
         DO J=1,JE
          DO I=1,IE
           IF (THO(I,J,1)*WETO(I,J,1).LT.-0.5) THEN
             SICTHO(I,J)=MAX(0.,3.*(-0.5-THO(I,J,1)))
             SICOMO(I,J)=1.
           ENDIF
          ENDDO
         ENDDO
       ENDIF ! ISTART

!  CHECK GLOBAL SALT CONTENT
 
       IF ( ICONTRO .ne. 0 ) THEN
          CALL CONTRO(24)
       ENDIF
 
!  SET AGE OF LEVITUS DATA
 
         LYEARS=0
         LMONTS=0 
         LDAYS=0 
         LDT = 0
         WRITE(IO_STDOUT,*)'TIME COUNTER SET TO ZERO ' 
 
!  SET LOGICAL UNIT FOR RESTART FILE; FOR FIRST RUN WRITE TO IO_IN_Z370
 
         IUNIT = IO_IN_Z380
         IFLAG = -1
!     WRITE RESTART FILES WITH INITIAL STRATIFICATION
!     MAKE SURE THAT BOTH RESTART FILES EXIST ON EXIT
         
      CALL AUFW
         CALL AUFW

      ENDIF

!
!-----------------------------------------------------------------------

!     START FROM RESTART FILES Z37000 OR Z38000

      IF (IAUFR .EQ. 1) THEN

         CALL AUFR

 
!  CHECK GLOBAL SALT CONTENT
        IF ( ICONTRO .ne. 0 ) THEN
         CALL CONTRO(13)
        ENDIF
      ENDIF
!
!-----------------------------------------------------------------------
! SET LIMITS OF YEAR/MONTH TIME STEPPING LOOP

      LDTRUN = 0

      LYEAR1 = LYEARS

      LMONT1 = LMONTS + 1

      IF (LMONT1 .GT. 12) THEN
         LMONT1=1
         LYEAR1=LYEAR1+1
      ENDIF

      LMONT2 = LMONT1 + MAX(0,12*NYEARS + NMONTS - 1)

      LYEAR2 = LYEAR1 + (LMONT2-1)/12

      LMONT2 = MOD(LMONT2-1,12)+1

# 1383


# 1389



# 1438



# 1449

!--------------------------------------------------------------------

# 1455


# 1460

      WRITE(IO_STDOUT,*)                                                &
     &'THIS RUN ASSUMES IDEALIZED YEARS WITH 365 DAYS'




      WRITE(IO_STDOUT,*)                                                &
     &' INTEGRATION PERIOD IS YEAR ',LYEAR1,' TO ',LYEAR2

# 1474



      DO 1000 LYEAR=LYEAR1,LYEAR2
         LYEARS=LYEAR
         LDTYEAR = 0 

         WRITE(IO_STDOUT,*) ' TO BE CALCULATED NOW : YEAR = ',LYEARS

# 1491





# 1499

       WRITE(IO_STDOUT,*) 'call spool omip'
       CALL spool_omip






!--------------------------------------------------------------------
!  SET NUMBER OF TIME STEPS PER YEAR

       ndtyear=0
       DO i=1,12
         ndtyear=ndtyear+monlen(i)*ndtday
       ENDDO


!  SET MONTH LOOP LIMITS FOR EACH YEAR

       LMON1=1
       LMON2=12
       IF(LYEAR1.EQ.LYEAR2) THEN
          LMON1=LMONT1
          LMON2=LMONT2
       ELSE
          IF(LYEARS.EQ.LYEAR2) THEN
             LMON1=1
             LMON2=LMONT2
          ENDIF          
          IF(LYEARS.EQ.LYEAR1) THEN
             LMON1=LMONT1
             LMON2=12
          ENDIF
       ENDIF
          WRITE(IO_STDOUT,*) 'MONTHLY LOOP FROM MONTH ',LMON1,          &
     &                        ' TO',LMON2

!:: MONTH LOOP
       DO 1100 LMONT=LMON1,LMON2
          LMONTS=LMONT
          LDTMONTH = 0

          NDTMONTH = MONLEN(LMONTS) * NDTDAY

          WRITE(IO_STDOUT,18823) LYEARS,LMONTS
18823     FORMAT(' TO BE CALCULATED NOW : YEAR ',I4,' MONTH ',I4)


# 1556



# 1573

!::
       IF (I3DREST .GT. 1) THEN
!:: REWIND INISAL/INITEM TO BEGIN OF YEAR
       IF(p_pe==p_io) THEN
         REWIND(IO_IN_INIT)
         REWIND(IO_IN_INIS)
       ENDIF
!:: READ APPROPRIATE INISAL/INITEM FOR MONTHLY RESTORING
       WRITE(IO_STDOUT,*)                                               &
     & 'READING MONTHLY LEVITUS FIELDS IN MONTH ',LMONT
       DO IREADC=1,LMONT
        CALL LEVIRE(-1)
       ENDDO
       ENDIF ! I3DREST

!::================================================================

      if (NDAYS.gt.0.and.NDAYS.lt.MONLEN(LMONTS)) then
         ENDDAY=NDAYS
      else
         if (NDAYS.gt.MONLEN(LMONTS)) then
            write(0,*)'ATTN: ndays greater than monlen(lmonts)'
            write(0,*)'=> ndays is set to ',monlen(lmonts)
         endif
         ENDDAY=MONLEN(LMONTS)
      endif

!::==================================================================

      DO 1010 LDAY=1,ENDDAY
      LDAYS=LDAY
      DO 1001 LDTDAY = 1,NDTDAY
      LDTDAYC = LDTDAY

# 1610


!*       6.  TIMESTEP THE OCEAN.
!            -------- --- ------
      LDT = LDT + 1
      LDTRUN = LDTRUN + 1
      LDTYEAR = LDTYEAR + 1
      LDTMONTH =LDTMONTH + 1

!  current date: yyyy-mm-dd (W3C XML Schema)
      IF (p_pe==p_io) THEN
        WRITE(0,'(a,i4.4,''-'',i2.2,''-'',i2.2,a,i3,a,i7)') &
             'MPIOM: current date: ', lyear,lmonts,lday, &
             ' begin of timestep (day):', ldtday,'  (run):', ldtrun
      ENDIF


# 1632




          IF (MOD(LDTDAY-1,NDTDAY) .EQ. 0) THEN
          WRITE(IO_STDOUT,*)'READ SURFACE FORCING AT TIMESTEP ',LDTDAY  &
                            ,LDAYS,LMONTS,LYEARS

# 1643

       WRITE(IO_STDOUT,*) 'call read omip'
       CALL read_omip

    ENDIF








# 1713


# 1718


!--------------------------------------------------------------------
! OCTHER : THERMODYNAMIC FORCING

# 1725


# 1729


      CALL OCICE

!      goto 999
      CALL OCTHER

!      write(0,*) 'without octher !!!'
       

# 1742

  123 FORMAT(a,f10.3)
!--------------------------------------------------------------------


# 1750




# 1757



       IF ( ICONTRO .ne. 0 ) THEN
          CALL CONTRO(1)
       ENDIF
!--------------------------------------------------------------------
! OCWIND :

      CALL OCWIND
!      PRINT*,'nach ocwind'

!--------------------------------------------------------------------
# 1773


!--------------------------------------------------------------------
!  OCTIMF : UPDATE VELOCITY
!
      CALL OCTIMF
!--------------------------------------------------------------------
!  OCMODMOM : DECOMPOSITION INTO BAROTROPIC AND BAROCLINIC FIELD

# 1784

      CALL OCMODMOM
# 1789


!--------------------------------------------------------------------

      CALL OCBARP

!      PRINT*,'nach ocbarp'
!
!--------------------------------------------------------------------
   
# 1801


      CALL OCCLIT

!      PRINT*,'nach occlit'
# 1809


!--------------------------------------------------------------------
     
# 1815

       IF ( ICONTRO .ne. 0 ) THEN
          call contro(38)
       endif

      IF(IELIMI.GE.1) THEN
       CALL BARTIM
      ELSE
        CALL TRONEU
      ENDIF
       IF ( ICONTRO .ne. 0 ) THEN
       call contro(39)
    endif
!      PRINT*,'nach troneu'
# 1832

60023 FORMAT(4E20.12)
!
!--------------------------------------------------------------------
      CALL OCVTRO
!      PRINT*,'nach ocvtro'
      CALL update_zo
!      call maschk(ie,je,ke,51)
!
!--------------------------------------------------------------------
!
# 1845

       IF ( ICONTRO .ne. 0 ) THEN
       call contro(40)
    endif
      CALL OCVTOT
!      PRINT*,'nach ocvtot'
       IF ( ICONTRO .ne. 0 ) THEN
       call contro(41)
       endif
# 1857

      if(imean.ne.0)then
         CALL WRTE_MFL(LDTDAY,LDAYS,LMONTS,LYEARS,IMEAN,NANF)
      endif
!
!UWE   RESET STABIO TO DRHODZ
       DO K=1,KE
        DO J=1,JE
         DO I=1,IE 
          STABIO(I,J,K)=(1000./DZ(K))*STABIO(I,J,K)
         ENDDO
        ENDDO
       ENDDO
       IF ( ICONTRO .ne. 0 ) THEN
       call contro(42)
    endif



       call calc_psi

!       call maschk(ie,je,ke,42)

       IF(MOD(LDTDAY,NDTDAY).EQ.NDTDAY/2)THEN
          CALL DIAGNOSIS
       ENDIF

!       call maschk(ie,je,ke,43)

       call calc_moc


# 1891

       IF ( ICONTRO .ne. 0 ) THEN
          call contro(43)
       endif
       CALL OCUAD(UOO)
       CALL OCVAD(VOE)
       IF ( ICONTRO .ne. 0 ) THEN
          call contro(44)
       endif
!!        write(0,*)'without ocuvad'

# 1905


      IF(IOCAD.EQ.4)THEN               ! SLOPECON_ADPO
         CALL SLOPETRANS
         IF ( ICONTRO .ne. 0 ) THEN
            CALL CONTRO(2)
         endif
      ENDIF


# 1917


      IF(IOCAD.EQ.3.OR.IOCAD.EQ.4)THEN

         CALL OCADPO(THO)
!:: SALT ADVECTION

        CALL OCADPO(SAO)

!       PRINT*,'nach adpo'
      ENDIF



       IF(IOCAD.EQ.5) CALL OCADFS
# 1935

 


!--------------------------------------------------------------------
# 2024

!--------------------------------------------------------------------



!      call maschk(ie,je,ke,46)


!--------------------------------------------------------------------

! OCJITR : ISOPYCNAL DIFFUSION (W/O GM PARAMETERISATION)
       CALL CONTRO(2712)
# 2038


       CALL OCJITR

!      call maschk(ie,je,ke,47)

# 2047

       IF ( ICONTRO .ne. 0 ) THEN
          CALL CONTRO(2713)
       endif

!--------------------------------------------------------------------


!  Tracer diffusion

# 2059


       call bounds_exch('p',rhoo,'mpiom 29')
!#ifdef bounds_exch_save
       call bounds_exch('p',tho,'mpiom 30')
       call bounds_exch('p',sao,'mpiom 31')
!#endif

       DO IMAL=1,1
          CALL OCTDIFF_BASE
          CALL OCTDIFF_TRF(tho)
          CALL OCTDIFF_TRF(sao)
       ENDDO

# 2076


!      call maschk(ie,je,ke,48)


       CALL RELAX_TS
       IF ( ICONTRO .ne. 0 ) THEN
          CALL CONTRO(4)
       endif

       CALL OCTIMF
       IF ( ICONTRO .ne. 0 ) THEN
          CALL CONTRO(5)
       endif
# 2112

!
!--------------------------------------------------------------------
!  MOMENTUM DIFFUSION
!
# 2119

       IF (AUS .GT. 1.E-12) CALL OCSCHEP
# 2124


!--------------------------------------------------------------------
!  BIHARMONIC MOMENTUM DIFFUSION, BOTTOM FRICTION,
!  SHEAR DEPENDENT DIFFUSION

# 2132


       CALL OCVISC

# 2139

       IF ( ICONTRO .ne. 0 ) THEN
          CALL CONTRO(6)
       endif

       CALL OCTIMF


# 2172


       if (iMEAN.ne.0)then
          CALL WRTE_MEAN(LDTDAY,LDAYS,LMONTS,LYEARS,IMEAN,NANF)
       endif

!mz_ap_20070515 !preproc comment
# 2182


 999   CONTINUE

# 2191

!
# 2198


# 2207



 1001 CONTINUE

! END OF ONE DAY
!----------------------------------------------------------------------

# 2220



 1010 CONTINUE


!#ifdef PBGC
!      CALL AVRG_BGCMEAN(ie,je,ke)
!#endif/*PBGC*/


# 2247


# 2251


          IF ( LCALCDIFI) THEN
             CALL CALC_DIFI((LYEARS*10000)+(LMONTS*100)+LDAYS)
          ENDIF

! END OF ONE MONTH
!----------------------------------------------------------------------
# 2261


 1100 CONTINUE


!  WRITE RESTART FILE AT END OF YEAR
      IF(IAUFW.EQ.1)THEN
        CALL AUFW
!        CALL AUFW_CDI
# 2273

      ELSE
        WRITE(IO_STDOUT,*)'STOPPED WITHOUT WRITING RESTART FILE         &
     &        AT END OF YEAR,                                                 &
     &                     IAUFW= ',IAUFW
      ENDIF


! END OF ONE YEAR
!----------------------------------------------------------------------

1000  CONTINUE

! END OF TIME STEPPING
!----------------------------------------------------------------------

# 2291


if (LGRIDINFO) then
       CALL WRTE_GRIDINFO(LYEAR2,LMONT2,MONLEN(LMONT2))
endif

# 2299


# 2307


# 2314


!     Branch target for finishing cleanly
99999 CONTINUE
      CALL print_stats

      WRITE(nerr,*) 'NORMAL END OF MPIOM'


  IF (util_cputime(zutime, zstime) == -1) THEN
     WRITE(nerr,*)'Cannot determine used CPU time'
  ELSE
     zwtime = util_walltime()
     zrtime = (zutime+zstime)/zwtime

     IF(p_pe==p_io) THEN
       WRITE (nerr,'(a,f10.2,a)') ' Wallclock        : ', zwtime, ' s'
       WRITE (nerr,'(a,f10.2,a)') ' CPU-time (user)  : ', zutime, ' s'
       WRITE (nerr,'(a,f10.2,a)') ' CPU-time (system): ', zstime, ' s'
       WRITE (nerr,'(a,f10.2,a)') ' Ratio            : ', 100*zrtime, ' %'
     END IF
  END IF


# 2340

      CALL p_stop
      END

# 2350











