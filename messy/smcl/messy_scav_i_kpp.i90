# 1 "messy_scav_i_kpp.f90"
Module messy_scav_i_kpp
 
! -*- f90 -*-

!  This module is automatically generated by create_mz_kpp.
!
!  FORTRAN Code generated by kpp was modified to be used
!
! NOTE: those are required for (some) reaction rates
  USE messy_main_constants_mem,ONLY: N_A,R_gas,atm2Pa
  USE messy_scav_inp_kpp   
  USE messy_main_tools,ONLY: read_nml_open,read_nml_check,read_nml_close &
                            ,str,find_next_free_unit


  IMPLICIT        NONE
  PRIVATE
!SAVE  ! NOTE: OCCURS AGAIN IN AUTOMATICALLY GENERATED CODE ...

  PUBLIC :: IERR_NAMES
 
  PUBLIC :: SPC_NAMES,EQN_NAMES,EQN_TAGS,REQ_HET,REQ_AEROSOL,REQ_PHOTRAT &
          ,REQ_MCFCT,IP_MAX

  PUBLIC :: dp
  PUBLIC :: atol,rtol
  PUBLIC :: NSPEC,nreact
  PUBLIC :: A
! mz_rs_20101111+
  PUBLIC :: rconst
! mz_rs_20101111-
! mz_rs_20130208+
  PUBLIC :: NVAR
! mz_rs_20130208-
 
  PUBLIC :: Initialize_i,Integrate,Update_RCONST,initialize_indexarrays
  PUBLIC :: kpp_integrate
  PUBLIC :: initialize_kpp_ctrl

  LOGICAL,PUBLIC,PARAMETER :: ivec=.TRUE.

! END OF MODULE HEADER TEMPLATE
                                                                 
! Variables used for vector mode
                                                                 
  logical,parameter           :: L_VECTOR=.FALSE.            
  integer,parameter           :: I_LU_DI = 1
  integer,parameter           :: VL_DIM=1
  integer                     :: vl                              
                                                                 
  integer                     :: VL_glo                          
  integer                     :: is,ie                           
                                                                 
  integer,dimension(VL_dim)   :: Kacc,Krej                       
  integer,dimension(VL_dim)   :: IERRV                           
  logical                     :: data_loaded=.false.             


!
!   Definition of different levels of accuracy
!   for REAL variables using KIND parameterization
!
!   KPP SP -  Single precision kind
  INTEGER, PARAMETER :: sp = SELECTED_REAL_KIND(6,30)
!   KPP DP -  Double precision kind
  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(12,307)
!   KPP QP -  Quadruple precision kind
  INTEGER, PARAMETER :: qp = SELECTED_REAL_KIND(18,400)



!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Parameter Module File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Parameters.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~






!   NSPEC -  Number of chemical species
  INTEGER, PARAMETER :: NSPEC = 4 
!   NVAR -  Number of Variable species
  INTEGER, PARAMETER :: NVAR = 3 
!   NVARACT -  Number of Active species
  INTEGER, PARAMETER :: NVARACT = 2 
!   NFIX -  Number of Fixed species
  INTEGER, PARAMETER :: NFIX = 1 
!   NREACT -  Number of reactions
  INTEGER, PARAMETER :: NREACT = 3 
!   NVARST -  Starting of variables in conc. vect.
  INTEGER, PARAMETER :: NVARST = 1 
!   NFIXST -  Starting of fixed in conc. vect.
  INTEGER, PARAMETER :: NFIXST = 4 
!   NONZERO -  Number of nonzero entries in Jacobian
  INTEGER, PARAMETER :: NONZERO = 5 
!   LU_NONZERO -  Number of nonzero entries in LU factoriz. of Jacobian
  INTEGER, PARAMETER :: LU_NONZERO = 5 
!   CNVAR -  (NVAR+ 1) Number of elements in compressed row format
  INTEGER, PARAMETER :: CNVAR = 4 
!   NLOOKAT -  Number of species to look at
  INTEGER, PARAMETER :: NLOOKAT = 0 
!   NMONITOR -  Number of species to monitor
  INTEGER, PARAMETER :: NMONITOR = 0 
!   NMASS -  Number of atoms to check mass balance
  INTEGER, PARAMETER :: NMASS = 1 

!   Index declaration for variable species in C and VAR
!     VAR(ind_spc) = C(ind_spc)

  INTEGER, PARAMETER,PUBLIC :: ind_CO2_i = 1 
  INTEGER, PARAMETER,PUBLIC :: ind_HNO3_i = 2 
  INTEGER, PARAMETER,PUBLIC :: ind_HNO3 = 3 

!   Index declaration for fixed species in C
!     C(ind_spc)

  INTEGER, PARAMETER,PUBLIC :: ind_CO2 = 4 

!   Index declaration for dummy species

  INTEGER, PARAMETER,PUBLIC :: ind_O1D = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O3P = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2OH2O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N2D = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NH3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N2O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N2O5 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HONO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HNO4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NH2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HNO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NHOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NH2O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NH2OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNITROGEN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2OO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2OOA = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3O2NO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3ONO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2O2NO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LCARBON = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H6 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2CHOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CHOHO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CHOHOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ETHGLY = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_GLYOX = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2CH2O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2CH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCHCHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOOCH2CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOOCH2CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOOCH2CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOOCH2CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HYETHO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5O2NO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ETHOHNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCCH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO3CH2CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO3CH2CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO3CH2PAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PHAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ACETOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ALCOCH2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PROPACID = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PERPROACID = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C33CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3H6 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3H8 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CHCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCH3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHOCOCH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCH2CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCH2CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCH2CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCH2CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCOCH2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOC2H4CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOC2H4CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOC2H4CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2COCH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2COCH2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2COCHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HYPERACET = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HYPROPO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HYPROPO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IC3H7O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IC3H7OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IPROPOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MGLYOX = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC3H7O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC3H7OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPROPOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PROPENOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C32OH13CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3DIALO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3DIALOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCOHCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCOHCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_METACETHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3PAN1 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3PAN2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCH2O2NO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IC3H7NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC3H7NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NOA = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PPN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PR2O2HNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PRONO3BO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PROPOLNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCOHPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIACET = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIACETO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIACETOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIACETOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BUT1ENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BUT2OLO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BUT2OLO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BUT2OLOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BUTENOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C312COCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C312COCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3H7CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C413COOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C44O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C44OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4CODIAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CBUT2ENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCHCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCHO2CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCOCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COOHCHCHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHOC3COO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO23C3CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO2C3CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO2H3CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO2H3CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO2H3CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO2H3CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EZCH3CO2CHCHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EZCHOCCH3CHO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCCH3CHOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCCH3CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOCO2CH3CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HMAC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HO12CO3C4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HVMK = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBUTALOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBUTDIAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBUTOLBO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBUTOLBOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IC4H10 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IC4H9O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IC4H9OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IPRCHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IPRCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IPRHOCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IPRHOCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IPRHOCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACR = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACRO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACRO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACROH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACROOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MBOOO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MEK = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MEPROPENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MPROPENOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MVK = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC4H10 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PERIBUACID = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TBUT2ENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TC4H9O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TC4H9OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZFUCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZFUO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZFUONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZFUOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO14O3CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO14O3CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO2C4DIAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EPXC4DIAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EPXDLCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EPXDLCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EPXDLCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCOC4DIAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALANHY = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALANHYO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALANHYOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALDALCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALDALCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALDIAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALDIALCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALDIALO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALDIALOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALNHYOHCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MECOACEOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MECOACETO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BUT2OLNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C312COPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4PAN5 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBUTOLBNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IC4H9NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MACRNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MVKNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PIPN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TC4H9NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EPXDLPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALDIALPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NBZFUO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NBZFUONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NBZFUOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC4DCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LBUT1ENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LBUT1ENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LC4H9O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LC4H9OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHMVKABO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHMVKABOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LMEKO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LMEKOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LBUT1ENNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LC4H9NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LMEKNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C1ODC2O2C4OD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C1ODC2O2C4OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C1ODC2OOHC4OD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C1ODC3O2C4OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C1OOHC2O2C4OD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C1OOHC2OOHC4OD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C1OOHC3O2C4OD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4MDIAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C511O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C511OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C512O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C512OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C513CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C513O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C513OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C514O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C514OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C59O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C59OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5H8 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHOC3COCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHOC3COOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO13C4CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO23C4CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO23C4CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO23C4CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DB1O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DB1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DB1OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DB2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DB2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOC5 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPAOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPBO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPBOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPBOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPDO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPDOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPDOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MBO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MBOACO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MBOCOCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ME3FURAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ACCOMECHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ACCOMECO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ACCOMECO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C24O3CCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4CO2DBCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4CO2DCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5134CO2OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C54CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO14O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO14OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO14OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5DIALCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5DIALO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5DIALOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5DICARB = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5DICARBO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5DICAROOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MC3ODBCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MMALANHY = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MMALANHYO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MMALNHYOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLFUO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLFUONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLFUOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4MCONO3OH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C514NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5PAN9 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHOC3COPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DB1NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPBDNO3O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPBNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPDNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC4CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC4OHCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC4OHCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC4OHCPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NISOPO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NISOPOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NMBOBCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ACCOMEPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4CO2DBPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5COO2NO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NC4MDCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NTLFUO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NTLFUOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LC578O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LC578OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LDISOPACO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LDISOPACO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHC4ACCHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHC4ACCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHC4ACCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHC4ACCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LIEPOX = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPAB = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPACO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPACO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPACOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPCD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPEFO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPEFO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LMBOABO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LMBOABOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LME3FURANO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LZCO3C23DBCOD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LZCO3HC23DBCOD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LZCODC23DBCOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LC5PAN1719 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPACNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPACNO3O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LMBOABNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNISO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNISOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNMBOABO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNMBOABOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LZCPANC23DBCOD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C614CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C614O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C614OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO235C5CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO235C6O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO235C6OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BENZENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZBIPERO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZBIPEROOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEPOXMUC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZOBIPEROH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO2DBCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO2DCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO2OHCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5COOHCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6125CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C615CO2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C615CO2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6CO4DB = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CATEC1O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CATEC1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CATEC1OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CATECHOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CPDKETENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PBZQCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PBZQO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PBZQONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PBZQOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PHENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PHENOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PHENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C614NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZBIPERNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZEMUCPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO2DBPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5CO2OHPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DNPHEN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DNPHENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DNPHENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOC6H4NO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NBZQO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NBZQOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCATECHOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCATECO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCATECOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCPDKETENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NDNPHENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NDNPHENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NNCATECO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NNCATECOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPHEN1O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPHEN1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPHEN1OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPHENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPHENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C235C6CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C716O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C716OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C721O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C721OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C722O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C722OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO235C6CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO235C6CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MCPDKETENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROO6R3O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROO6R3O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROO6R5O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BENZAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6CO2OHCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6COOHCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5CH2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5CH2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C7CO4DB = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CRESO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CRESOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CRESOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MCATEC1O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MCATEC1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MCATEC1OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MCATECHOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OXYL1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OXYL1OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PHCOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PTLQCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PTLQO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PTLQONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PTLQOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLBIPERO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLBIPEROOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCCO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCCO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCCO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEPOXMUC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLOBIPEROH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TOL1O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TOLUENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C7PAN3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6CO2OHPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C6H5CH2NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DNCRES = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DNCRESO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DNCRESOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MNCATECH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MNCATECO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MNCATECOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MNCPDKETENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MNNCATCOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MNNCATECO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCRES1O = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCRES1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCRES1OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCRESO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NCRESOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NDNCRESO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NDNCRESOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPTLQO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NPTLQOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PBZN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLBIPERNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TLEMUCPAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TOL1OHNO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C721CHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C721CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C721CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C810O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C810OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C811O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C812O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C812OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C813O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C813OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C85O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C85OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C86O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C86OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C89O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C89OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C8BC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C8BCCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C8BCO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C8BCOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NORPINIC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EBENZ = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_STYRENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_STYRENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_STYRENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C721PAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C810NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C89NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C8BCNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NSTYRENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NSTYRENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LXYL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C811CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C811CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C85CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C85CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C89CO2H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C89CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C89CO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C96O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C96OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C97O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C97OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C98O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C98OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NOPINDCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NOPINDO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NOPINDOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NOPINONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NOPINOO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NORPINAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NORPINENOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PINIC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C811PAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C89PAN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C96NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C9PAN2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LTMB = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_APINAOO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_APINBOO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_APINENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BPINAO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BPINAOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BPINENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C106O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C106OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C109CO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C109O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C109OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C96CO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CAMPHENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CARENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MENTHEN6ONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OH2MENTHEN6ONE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHMENTHEN6ONEO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PERPINONIC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PINAL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PINALO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PINALOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PINENOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PINONIC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_RO6R1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_RO6R3O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROO6R1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SABINENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BPINANO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C106NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C10PAN2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PINALNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_RO6R1NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROO6R1NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LAPINABNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LAPINABO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LAPINABOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNAPINABO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNAPINABOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNBPINABO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LNBPINABOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHAROM = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LFLUORINE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHF3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHF2CF3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CF3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2F2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CHF2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CCl4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF2Cl2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF2ClCF2Cl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF2ClCFCl2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF3CF2Cl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CFCl3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2Cl2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2FCF3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CCl3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CFCl2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3Cl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHCl3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHF2Cl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Cl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Cl2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Cl2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClNO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OClO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LCHLORINE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Br = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Br2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrCl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrNO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF2ClBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF3Br = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2Br2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2ClBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3Br = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHBr3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHCl2Br = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CHClBr2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LBROMINE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3H7I = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2ClI = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2I2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3I = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HI = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HIO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOI = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_I = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_I2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_I2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ICl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_INO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_INO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IPART = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OIO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3SO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3SO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3SO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DMS = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DMSO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2SO4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OCS = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_S = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SF6 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LSULFUR = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Hg = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HgO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HgCl = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HgCl2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HgBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HgBr2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClHgBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrHgOBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClHgOBr = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO3m_cs = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Hp_cs = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_RGM_cs = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Dummy = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PRODUCTS = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_M = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O3s = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LO3s = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISON = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHOC3H6O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LHOC3H6OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MVKO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MVKOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NACA = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Op = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2p = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Np = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N2p = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NOp = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_em = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_kJmol = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O4Sp = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2Dp = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2Pp = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CFCl3_c = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF2Cl2_c = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N2O_c = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CCl3_c = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF2ClBr_c = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CF3Br_c = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LTERP = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LALK4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LALK5 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LARO1 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LARO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LOLE1 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LOLE2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfPOG02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfPOG03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfPOG04 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfPOG05 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbPOG02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbPOG03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbPOG04 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfSOGsv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfSOGsv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbSOGsv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbSOGsv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfSOGiv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfSOGiv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfSOGiv03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LfSOGiv04 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbSOGiv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbSOGiv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbbSOGiv03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbSOGv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbSOGv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbSOGv03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbSOGv04 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbOSOGv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbOSOGv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LbOSOGv03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LaSOGv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LaSOGv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LaSOGv03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LaSOGv04 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LaOSOGv01 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LaOSOGv02 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LaOSOGv03 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ACBZO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ALKNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ALKO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ALKOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ALKOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BCARY = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BENZO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BENZOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BEPOMUC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIGALD1 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIGALD2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIGALD3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIGALD4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIGALKANE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BIGENE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrONO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZALD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZOO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BZOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3H7O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C3H7OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CFC113 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CFC114 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CFC115 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_COF2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_COFCL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DICARBO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ELVOC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ENEO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_EOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_F = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H1202 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2402 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCFC141B = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCFC142B = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCFC22 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HF = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCH2OO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HPALD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IEC1O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LIECHO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LIECO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LIECO3H = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LIMON = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPNO3NO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPNO3O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPNO3OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPOOHO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_LISOPOOHOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MALO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MBONO3O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MBOO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MBOOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MDIALO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MEKNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MVKN = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_MYRC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NTERPNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NTERPO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PACALD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PBZNIT = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TEPOMUC = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TERP2O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TERP2OOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TERPNO3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TERPO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TERPOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TERPROD1 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TERPROD2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TOLO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TOLOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_XYLENO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_XYLENOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_XYLOL = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_XYLOLO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_XYLOLOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2_1D = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2_1S = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ONIT = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4H8 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C4H9O3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5H12 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5H11O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5H6O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HYDRALD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5H9O3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISOPOOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5H12O2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ONITR = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C5H10O4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROO6R5P = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NH4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ISPD = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClOO = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Rn = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Pb = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_XO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_XO2N = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROOH = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OLE = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ROR = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ORGNTR = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ACO2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PAR = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_RXPAR = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DMP = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DMB = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_TM5 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv0 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv1 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv2 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv3 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv4 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv5 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv6 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv7 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv8 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHv9 = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O1S = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O21d = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2b1s = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2c1s = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2x = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2A3D = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2A3S = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O25P = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O3_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OH_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HO2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2O_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2O2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NH3_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO3_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HONO_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HNO4_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_N2O5_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3OH_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOOH_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCHO_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3O2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3OOH_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CO2H_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PAN_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_C2H5O2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3CHO_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COCH3_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Cl_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Cl2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCl_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOCl_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Br_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Br2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HBr_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOBr_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrCl_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_I2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IO_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HI_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HOI_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ICl_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBr_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HIO3_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_H2SO4_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DMSO_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_O2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_OHm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Hp_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NH4p_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_NO4m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCOOm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HCO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3COOm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Clm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Cl2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClOm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ClOHm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Brm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Br2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrOm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrOHm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_BrCl2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Br2Clm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Im_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IO2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_ICl2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IClBrm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_IBr2m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO3mm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO4m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO4mm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_SO5m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HSO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HSO4m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_HSO5m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH3SO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_CH2OHSO3m_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_D1O_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_D2O_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DAHp_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DA_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DAm_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DGtAi_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_DGtAs_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PROD1_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_PROD2_i = 0 
  INTEGER, PARAMETER,PUBLIC :: ind_Nap_i = 0 

!   Index declaration for fixed species in FIX
!      FIX(indf_spc) = C(ind_spc) = C(NVAR+ indf_spc)

  INTEGER, PARAMETER :: indf_CO2 = 1 


!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Global Data Module File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Global.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~






!   Declaration of global variables

!   C -  Concentration of all species
  REAL(kind=dp) :: C(NSPEC)
!   VAR -  Concentrations of variable species (global)
  REAL(kind=dp) :: VAR(NVAR)
!   FIX -  Concentrations of fixed species (global)
  REAL(kind=dp) :: FIX(NFIX)
!   VAR, FIX are chunks of array C
      EQUIVALENCE( C(1),VAR(1))
      EQUIVALENCE( C(4),FIX(1))
!   RCONST -  Rate constants (global)
  REAL(kind=dp) :: RCONST(NREACT)
!   TIME -  Current integration time
  REAL(kind=dp) :: TIME
!   SUN -  Sunlight intensity between [0,1]
  REAL(kind=dp) :: SUN
!   TEMP -  Temperature
  REAL(dp),dimension(:),allocatable             :: TEMP
!   TSTART -  Integration start time
  REAL(kind=dp) :: TSTART
!   TEND -  Integration end time
  REAL(kind=dp) :: TEND
!   DT -  Integration step
  REAL(kind=dp) :: DT
!   ATOL -  Absolute tolerance
  REAL(kind=dp) :: ATOL(NVAR)
!   RTOL -  Relative tolerance
  REAL(kind=dp) :: RTOL(NVAR)
!   STEPMIN -  Lower bound for integration step
  REAL(kind=dp) :: STEPMIN
!   STEPMAX -  Upper bound for integration step
  REAL(kind=dp) :: STEPMAX
!   CFACTOR -  Conversion factor for concentration units
  REAL(kind=dp) :: CFACTOR

!   INLINED global variable declarations

!  SCAV info from xscav_i:
  CHARACTER(LEN=*), PUBLIC, PARAMETER :: &
    timestamp            = 'xscav was run on 2020-11-16 at 17:05:46 by joec_pa on machine lx134.pa.op.dlr.de',&
    batchfile            = 'ice.bat',&
    gas_spc_file         = 'lrwxrwxrwx 1 joec_pa pa_ac_mf 25 Aug 13 14:34 gas.spc -> ../../caaba/mecca/gas.spc',&
    aqueous_spc_file     = '-rw------- 1 joec_pa pa_ac_mf 7176 Oct 12  2018 ice.spc',&
    gas_eqn_file         = 'lrwxrwxrwx 1 joec_pa pa_ac_mf 25 Aug 13 14:34 gas.eqn -> ../../caaba/mecca/gas.eqn',&
    aqueous_eqn_file     = '-rw------- 1 joec_pa pa_ac_mf 5258 Aug 13 14:34 ice.eqn',&
    gas_spc_file_sum     = '12686    77',&
    aqueous_spc_file_sum = '49717     8',&
    gas_eqn_file_sum     = '30123   312',&
    aqueous_eqn_file_sum = '19308     6',&
    rplfile              = '',&
    wanted               = '(Sc)',&
    diagtracfile         = '',&
    rxnrates             = 'n',&
    tag                  = 'n'
  LOGICAL, PARAMETER :: REQ_MCFCT = .FALSE.

!  from xscav_i for aerosol:
  INTEGER, PARAMETER, PUBLIC :: APN = 1
!  from aerosol.awk:

!  from xscav_i:
  LOGICAL, PARAMETER :: REQ_HET     = .FALSE.
  LOGICAL, PARAMETER :: REQ_PHOTRAT = .FALSE.
  LOGICAL, PARAMETER :: REQ_AEROSOL = .FALSE.

!  from xscav_i:
  INTEGER, PARAMETER, PUBLIC :: MAX_MCEXP = 1
!KPPPP_DIRECTIVE vector variable definition start
  REAL(dp),dimension(:,:),allocatable           :: mcexp
!KPPPP_DIRECTIVE vector variable definition end

!KPPPP_DIRECTIVE vector variable definition start
!  IMPORTANT NOTES ABOUT TEMP, PRESS, AND CAIR:
!  -  The KPP variable "temp" is already defined automatically by KPP in
!    messy_mecca_kpp_global.f90. The KPP variables "press" and "cair" are
!    defined here.
!  -  The 3 variables temp, press, and cair are only used inside KPP.
!    They are different from the variables with the same names in the base
!    model (as used in the SMIL files *_si.f90 and *_box.f90)
!  -  Data transfer between the SMIL and the KPP variables is done via the
!    fill subroutines in messy_mecca_kpp.f90:
!    -  fill_temp transfers temperature
!    -  fill_press transfers pressure
!    -  fill_cair transfers cair (this is redundant because cair could be
!      calculated from temp and press; nevertheless, redundant transfer to
!      KPP is preferred to avoid potential numerical differences when
!      recalculating cair inside KPP)
  REAL(dp),dimension(:),allocatable             :: cair
  REAL(dp),dimension(:),allocatable             :: press
  REAL(dp),dimension(:),allocatable             :: cv_l
  REAL(dp),dimension(:),allocatable             :: lwc
  REAL(dp),dimension(:,:),allocatable           :: k_exf
  REAL(dp),dimension(:,:),allocatable           :: k_exb
  REAL(dp),dimension(:),allocatable             :: k_exf_N2O5
  REAL(dp),dimension(:),allocatable             :: k_exf_ClNO3
  REAL(dp),dimension(:),allocatable             :: k_exf_BrNO3
  REAL(dp),dimension(:,:),allocatable           :: jx
!KPPPP_DIRECTIVE vector variable definition end
  INTEGER, PUBLIC  :: xnom7sulf = 1  !  = 1- xm7sulf

!  KPP info from xmecca:
  CHARACTER(LEN=*), PUBLIC, PARAMETER :: &
    scav_spc_file     = '-rw------- 1 joec_pa pa_ac_mf 87215 Nov 16 17:06 scav.spc',&
    scav_eqn_file     = '-rw------- 1 joec_pa pa_ac_mf 5129 Nov 16 17:06 scav.eqn',&
    scav_spc_file_sum = '57787    86',&
    scav_eqn_file_sum = '29345     6',&
    kppoption          = '4',&
    KPP_HOME           = '/export/home/joec_pa/MESSY/REPO/MESSy/messy/tools/kpp',&
    KPP_version        = '2.2.3_rs3',&
    integr             = 'rosenbrock_mz'

!   INLINED global variable declarations



!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Sparse Jacobian Data Structures File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_JacobianSP.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~






!   Sparse Jacobian Data


  INTEGER, PARAMETER, DIMENSION(5) :: LU_IROW =  (/ &
       1,  2,  2,  3,  3 /) 

  INTEGER, PARAMETER, DIMENSION(5) :: LU_ICOL =  (/ &
       1,  2,  3,  2,  3 /) 

  INTEGER, PARAMETER, DIMENSION(4) :: LU_CROW =  (/ &
       1,  2,  4,  6 /) 

  INTEGER, PARAMETER, DIMENSION(4) :: LU_DIAG =  (/ &
       1,  2,  5,  6 /) 



!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Utility Data Module File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Monitor.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





  CHARACTER(LEN=32), PARAMETER, DIMENSION(4) :: SPC_NAMES =  (/ &
     'CO2_i                           ','HNO3_i                          ','HNO3                            ',&
     'CO2                             ' /)

  INTEGER, DIMENSION(1) :: LOOKAT
  INTEGER, DIMENSION(1) :: MONITOR
  CHARACTER(LEN=32), DIMENSION(1) :: SMASS
  CHARACTER(LEN=100), PARAMETER, DIMENSION(3) :: EQN_NAMES =  (/ &
     '  HNO3 --> HNO3_i                                                                                   ',&
     'HNO3_i --> HNO3                                                                                     ',&
     '   CO2 --> CO2_i                                                                                    ' /)

  CHARACTER(LEN=32), PARAMETER, DIMENSION(3) :: EQN_TAGS =  (/ &
     'H3203f_i                        ','H3203b_i                        ','H4100f_i                        ' /)

!   INLINED global variables

!   End INLINED global variables


! Automatic generated PUBLIC Statements for ip_ and ihs_ variables
 
! Automatic generated PUBLIC Statements for ip_ and ihs_ variables
 
! Automatic generated PUBLIC Statements for ip_ and ihs_ variables
 
! Automatic generated PUBLIC Statements for ip_ and ihs_ variables
 
! Automatic generated PUBLIC Statements for ip_ and ihs_ variables
 
 
!  variable definations from  individual module headers
 
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Initialization File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Initialize.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Numerical Integrator (Time-Stepping) File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Integrator.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   INTEGRATE -  Integrator routine
!     Arguments :
!        TIN       -  Start Time for Integration
!        TOUT      -  End Time for Integration
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  SAVE
!  ~~~>  Statistics on the work performed by the Rosenbrock method
  INTEGER :: Nfun,Njac,Nstp,Nacc,Nrej,Ndec,Nsol,Nsng
  INTEGER, PARAMETER :: ifun=1, ijac=2, istp=3, iacc=4, &
    irej=5, idec=6, isol=7, isng=8, itexit=1, ihexit=2
    

!  description of the error numbers IERR
  CHARACTER(LEN=50), PARAMETER, DIMENSION(- 8:1) :: IERR_NAMES =  (/&
    'Matrix is repeatedly singular                     ',& ! -8
    'Step size too small                               ',& ! -7
    'No of steps exceeds maximum bound                 ',& ! -6
    'Improper tolerance values                         ',& ! -5
    'FacMin/FacMax/FacRej must be positive             ',& ! -4
    'Hmin/Hmax/Hstart must be positive                 ',& ! -3
    'Selected Rosenbrock method not implemented        ',& ! -2
    'Improper value for maximal no of steps            ',& ! -1
    '                                                  ',& !  0 (not used)
    'Success                                           ' /) !  1

!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Linear Algebra Data and Routines File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_LinearAlgebra.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~






!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   The ODE Jacobian of Chemical Model File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Jacobian.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~






!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   The ODE Function of Chemical Model File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Function.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





!   A -  Rate for each equation
  REAL(kind=dp) :: A(NREACT)

!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   The Reaction Rates File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Rates.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!   Auxiliary Routines File
!
!   Generated by KPP- 2.2.3_rs3 symbolic chemistry Kinetics PreProcessor
!         (http://www.cs.vt.edu/~asandu/Software/KPP)
!   KPP is distributed under GPL, the general public licence
!         (http://www.gnu.org/copyleft/gpl.html)
!   (C) 1995- 1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
!   (C) 1997- 2005, A. Sandu, Michigan Tech, Virginia Tech
!       With important contributions from:
!          M. Damian, Villanova University, USA
!          R. Sander, Max- Planck Institute for Chemistry, Mainz, Germany
!
!   File                 : messy_scav_i_kpp_Util.f90
!   Time                 : Mon Nov 16 17:06:09 2020
!   Working directory    : /export/home/joec_pa/1/REPO/MESSy/messy/tools/kp4/tmp_workdir
!   Equation file        : messy_scav_i_kpp.kpp
!   Output root filename : messy_scav_i_kpp
!
!   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~






!  HEADER MODULE initialize_kpp_ctrl_template

!  NOTES:
!  -  L_VECTOR is automatically defined by kp4
!  -  VL_DIM is automatically defined by kp4
!  -  I_LU_DI is automatically defined by kp4
!  -  WANTED is automatically defined by xmecca
!  -  ICNTRL RCNTRL are automatically defined by kpp
!  -  "USE messy_main_tools" is in Module_header of messy_mecca_kpp.f90
!  -  SAVE will be automatically added by kp4

! SAVE

!  FOR FIXED TIME STEP CONTROL
!  ... max. number of fixed time steps (sum must be 1)
  INTEGER, PARAMETER         :: NMAXFIXSTEPS = 50
!  ... switch for fixed time stepping
  LOGICAL, PUBLIC            :: l_fixed_step = .FALSE.
  INTEGER, PUBLIC            :: nfsteps = 1
!  ... number of kpp control parameters
  INTEGER, PARAMETER, PUBLIC :: NKPPCTRL = 20
!
  INTEGER,  DIMENSION(NKPPCTRL), PUBLIC     :: icntrl = 0
  REAL(DP), DIMENSION(NKPPCTRL), PUBLIC     :: rcntrl = 0.0_dp
  REAL(DP), DIMENSION(NMAXFIXSTEPS), PUBLIC :: t_steps = 0.0_dp

!  END HEADER MODULE initialize_kpp_ctrl_template

 
! Interface Block
 
  interface            Initialize_i
    module procedure   Initialize_i
  end interface        Initialize_i
 
  interface            INTEGRATE
    module procedure   INTEGRATE
  end interface        INTEGRATE
 
  interface            Fun
    module procedure   Fun
  end interface        Fun
 
  interface            Fun_SPLIT
    module procedure   Fun_SPLIT
  end interface        Fun_SPLIT
 
  interface            CalcStoichNum
    module procedure   CalcStoichNum
  end interface        CalcStoichNum
 
  interface            KppSolve
    module procedure   KppSolve
  end interface        KppSolve
 
  interface            WLAMCH
    module procedure   WLAMCH
  end interface        WLAMCH
 
  interface            WLAMCH_ADD
    module procedure   WLAMCH_ADD
  end interface        WLAMCH_ADD
 
  interface            Jac_SP
    module procedure   Jac_SP
  end interface        Jac_SP
 
  interface            Update_RCONST
    module procedure   Update_RCONST
  end interface        Update_RCONST
 
  interface            initialize_indexarrays
    module procedure   initialize_indexarrays
  end interface        initialize_indexarrays
 
  interface            initialize_kpp_ctrl
    module procedure   initialize_kpp_ctrl
  end interface        initialize_kpp_ctrl
 
  interface            k_arr
    module procedure   k_arr
  end interface        k_arr
 
!interface not working  interface            WCOPY
!interface not working    module procedure   WCOPY
!interface not working  end interface        WCOPY
 
  interface            WSCAL
    module procedure   WSCAL
  end interface        WSCAL
 
!interface not working  interface            WAXPY
!interface not working    module procedure   WAXPY
!interface not working  end interface        WAXPY
 
  interface            Rosenbrock
    module procedure   Rosenbrock
  end interface        Rosenbrock
 
  interface            FunTemplate
    module procedure   FunTemplate
  end interface        FunTemplate
 
  interface            JacTemplate
    module procedure   JacTemplate
  end interface        JacTemplate
 
  interface            Update_SUN
    module procedure   Update_SUN
  end interface        Update_SUN
 
  interface            error_output
    module procedure   error_output
  end interface        error_output
 
  interface            KppDecomp
    module procedure   KppDecomp
  end interface        KppDecomp
 
  interface            kpp_integrate
    module procedure   kpp_integrate
  end interface        kpp_integrate
 
  interface            fill_TEMP
    module procedure   fill_TEMP
  end interface        fill_TEMP
  public               fill_TEMP
 
  interface            fill_mcexp
    module procedure   fill_mcexp
  end interface        fill_mcexp
  public               fill_mcexp
 
  interface            fill_cair
    module procedure   fill_cair
  end interface        fill_cair
  public               fill_cair
 
  interface            fill_press
    module procedure   fill_press
  end interface        fill_press
  public               fill_press
 
  interface            fill_cv_l
    module procedure   fill_cv_l
  end interface        fill_cv_l
  public               fill_cv_l
 
  interface            fill_lwc
    module procedure   fill_lwc
  end interface        fill_lwc
  public               fill_lwc
 
  interface            fill_k_exf
    module procedure   fill_k_exf
  end interface        fill_k_exf
  public               fill_k_exf
 
  interface            fill_k_exb
    module procedure   fill_k_exb
  end interface        fill_k_exb
  public               fill_k_exb
 
  interface            fill_k_exf_N2O5
    module procedure   fill_k_exf_N2O5
  end interface        fill_k_exf_N2O5
  public               fill_k_exf_N2O5
 
  interface            fill_k_exf_ClNO3
    module procedure   fill_k_exf_ClNO3
  end interface        fill_k_exf_ClNO3
  public               fill_k_exf_ClNO3
 
  interface            fill_k_exf_BrNO3
    module procedure   fill_k_exf_BrNO3
  end interface        fill_k_exf_BrNO3
  public               fill_k_exf_BrNO3
 
  interface            fill_jx
    module procedure   fill_jx
  end interface        fill_jx
  public               fill_jx
 
 
 CONTAINS
 
SUBROUTINE Initialize_i()




  INTEGER :: i
  REAL(kind=dp) :: x

  CFACTOR = 1.000000e+00_dp

  x = (0.)*CFACTOR
  DO i = 1, NVAR
    VAR(i) = x
  END DO

  x = (0.)*CFACTOR
  DO i = 1, NFIX
    FIX(i) = x
  END DO

!   constant rate coefficients
  RCONST(3) = 0
!   END constant rate coefficients

!   INLINED initializations

  rtol(:) = 1E-2_dp  !  relative tolerance
  atol(:) = 1E1_dp   !  absolute tolerance

!   End INLINED initializations

      
END SUBROUTINE Initialize_i
 
SUBROUTINE INTEGRATE( TIN, TOUT, &
  ICNTRL_U, RCNTRL_U, ISTATUS_U, RSTATUS_U, IERR_U)


   REAL(kind=dp), INTENT(IN) :: TIN   !  Start Time
   REAL(kind=dp), INTENT(IN) :: TOUT  !  End Time
!  Optional input parameters and statistics
   INTEGER,  INTENT(IN),  OPTIONAL :: ICNTRL_U(20)
   REAL(kind=dp), INTENT(IN),  OPTIONAL :: RCNTRL_U(20)
   INTEGER,  INTENT(OUT), OPTIONAL :: ISTATUS_U(20)
   REAL(kind=dp), INTENT(OUT), OPTIONAL :: RSTATUS_U(20)
   INTEGER,  INTENT(OUT), OPTIONAL :: IERR_U

   INTEGER :: N_stp, N_acc, N_rej, N_sng
   SAVE N_stp, N_acc, N_rej, N_sng
   INTEGER :: i, IERR
   REAL(kind=dp) :: RCNTRL(20), RSTATUS(20)
   INTEGER :: ICNTRL(20), ISTATUS(20)

   ICNTRL(:)  = 0
   RCNTRL(:)  = 0.0_dp
   ISTATUS(:) = 0
   RSTATUS(:) = 0.0_dp

!  If optional parameters are given, and if they are >0,
!  then they overwrite default settings.
   IF (PRESENT(ICNTRL_U))THEN
     WHERE(ICNTRL_U(:) > 0) ICNTRL(:) = ICNTRL_U(:)
   END IF
   IF (PRESENT(RCNTRL_U))THEN
     WHERE(RCNTRL_U(:) > 0) RCNTRL(:) = RCNTRL_U(:)
   END IF

   CALL Rosenbrock(VAR,TIN,TOUT,   &
         ATOL,RTOL,                &
         RCNTRL,ICNTRL,RSTATUS,ISTATUS,IERR)

   STEPMIN = RCNTRL(ihexit)
!  if optional parameters are given for output they to return information
   IF (PRESENT(ISTATUS_U))ISTATUS_U(:) = ISTATUS(:)
   IF (PRESENT(RSTATUS_U))RSTATUS_U(:) = RSTATUS(:)
   IF (PRESENT(IERR_U))   IERR_U       = IERR

END SUBROUTINE INTEGRATE
 
SUBROUTINE Fun(V, F, RCT, Vdot)

!   V -  Concentrations of variable species (local)
  REAL(kind=dp) :: V(NVAR)
!   F -  Concentrations of fixed species (local)
  REAL(kind=dp) :: F(NFIX)
!   RCT -  Rate constants (local)
  REAL(kind=dp) :: RCT(NREACT)
!   Vdot -  Time derivative of variable species concentrations
  REAL(kind=dp) :: Vdot(NVAR)


!   Computation of equation rates
  A(1) = RCT(1)*V(3)
  A(2) = RCT(2)*V(2)
  A(3) = 0

!   Aggregate function
  Vdot(1) = A(3)
  Vdot(2) = A(1)- A(2)
  Vdot(3) = - A(1)+ A(2)
      
END SUBROUTINE Fun
 
SUBROUTINE Fun_SPLIT(V, F, RCT, P_VAR, D_VAR)

!   V -  Concentrations of variable species (local)
  REAL(kind=dp) :: V(NVAR)
!   F -  Concentrations of fixed species (local)
  REAL(kind=dp) :: F(NFIX)
!   RCT -  Rate constants (local)
  REAL(kind=dp) :: RCT(NREACT)
!   P_VAR -  Production term
  REAL(kind=dp) :: P_VAR(NVAR)
!   D_VAR -  Destruction term
  REAL(kind=dp) :: D_VAR(NVAR)


!   Computation of equation rates
  A(1) = RCT(1)*V(3)
  A(2) = RCT(2)*V(2)
  A(3) = 0

!   Production function
  P_VAR(1) = A(3)
  P_VAR(2) = A(1)
  P_VAR(3) = A(2)

!   Destruction function
  D_VAR(1) = 0
  D_VAR(2) = RCT(2)
  D_VAR(3) = RCT(1)
      
END SUBROUTINE Fun_SPLIT
 
SUBROUTINE CalcStoichNum(StoichNum)

!   StoichNum -  Stoichiometric numbers
  REAL(kind=dp) :: StoichNum(NVAR,NREACT)

  StoichNum(:,:) = 0.
  StoichNum(1,3) = 1
  StoichNum(2,1) = 1
  StoichNum(2,2) = - 1
  StoichNum(3,1) = - 1
  StoichNum(3,2) = 1
      
END SUBROUTINE CalcStoichNum
 
SUBROUTINE KppSolve(JVS, X)

!   JVS -  sparse Jacobian of variables
  REAL(kind=dp) :: JVS(LU_NONZERO)
!   X -  Vector for variables
  REAL(kind=dp) :: X(NVAR)

  X(3) = X(3)- JVS(4)*X(2)
  X(3) = X(3)/ JVS(5)
  X(2) = (X(2)- JVS(3)*X(3))/(JVS(2))
  X(1) = X(1)/ JVS(1)
      
END SUBROUTINE KppSolve
 
      REAL(kind=dp) FUNCTION WLAMCH( C)
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       returns epsilon machine
!       after LAPACK
!       replace this by the function from the optimized LAPACK implementation:
!          CALL SLAMCH('E') or CALL DLAMCH('E')
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!        USE messy_scav_i_kpp_Precision

      CHARACTER ::  C
      INTEGER    :: i
      REAL(kind=dp), SAVE  ::  Eps
      REAL(kind=dp)  ::  Suma
      REAL(kind=dp), PARAMETER  ::  ONE=1.0_dp, HALF=0.5_dp
      LOGICAL, SAVE   ::  First=.TRUE.
      
      IF (First) THEN
        First = .FALSE.
        Eps = HALF**(16)
        DO i = 17, 80
          Eps = Eps*HALF
          CALL WLAMCH_ADD(ONE,Eps,Suma)
          IF (Suma.LE.ONE) GOTO 10
        END DO
        PRINT*,'ERROR IN WLAMCH. EPS < ',Eps
        RETURN
10      Eps = Eps*2
        i = i- 1      
      END IF

      WLAMCH = Eps

      END FUNCTION WLAMCH
 
      SUBROUTINE WLAMCH_ADD( A, B, Suma)
!        USE messy_scav_i_kpp_Precision
      
      REAL(kind=dp) A, B, Suma
      Suma = A +  B

      END SUBROUTINE WLAMCH_ADD
 
SUBROUTINE Jac_SP(V, F, RCT, JVS)

!   V -  Concentrations of variable species (local)
  REAL(kind=dp) :: V(NVAR)
!   F -  Concentrations of fixed species (local)
  REAL(kind=dp) :: F(NFIX)
!   RCT -  Rate constants (local)
  REAL(kind=dp) :: RCT(NREACT)
!   JVS -  sparse Jacobian of variables
  REAL(kind=dp) :: JVS(LU_NONZERO)


!   Local variables
!   B -  Temporary array
  REAL(kind=dp) :: B(3)

!   B(1) = dA(1)/dV(3)
  B(1) = RCT(1)
!   B(2) = dA(2)/dV(2)
  B(2) = RCT(2)

! Construct the Jacobian terms from B's
!   JVS(1) = Jac_FULL(1,1)
  JVS(1) = 0
!   JVS(2) = Jac_FULL(2,2)
  JVS(2) = - B(2)
!   JVS(3) = Jac_FULL(2,3)
  JVS(3) = B(1)
!   JVS(4) = Jac_FULL(3,2)
  JVS(4) = B(2)
!   JVS(5) = Jac_FULL(3,3)
  JVS(5) = - B(1)
      
END SUBROUTINE Jac_SP
 
SUBROUTINE Update_RCONST()
 integer         :: j,k

  k = is

!   Begin INLINED RCONST


!  end of USE statements

!   End INLINED RCONST

  RCONST(1) = (k_exf (k,ind_HNO3))
  RCONST(2) = (k_exb (k,ind_HNO3))
!   RCONST(3) = constant rate coefficient
      
END SUBROUTINE Update_RCONST
 
SUBROUTINE initialize_indexarrays
!  from aerosol.awk:
END SUBROUTINE initialize_indexarrays
 
SUBROUTINE initialize_kpp_ctrl(status, iou, modstr)


!  I/O
  INTEGER,          INTENT(OUT) :: status
  INTEGER,          INTENT(IN)  :: iou      !  logical I/O unit
  CHARACTER(LEN=*), INTENT(IN)  :: modstr   !  read <modstr>.nml

!  LOCAL
  REAL(DP) :: tsum
  INTEGER  :: i

  CALL kpp_read_nml_ctrl(status, iou)
  IF (status /= 0) RETURN

!  check fixed time steps
  tsum = 0.0_dp
  DO i=1, NMAXFIXSTEPS
     IF (t_steps(i) < TINY(0.0_DP))EXIT
     tsum = tsum +  t_steps(i)
  END DO

  nfsteps = i- 1

  l_fixed_step = (nfsteps > 0) .AND.((tsum - 1.0) < TINY(0.0_DP))

!  mz_pj_20070531+
!  DIAGNOSTIC OUTPUT TO LOG- FILE
  WRITE(*,*) ' MECHANISM        : ',WANTED
!
  IF (L_VECTOR) THEN
     WRITE(*,*) ' MODE             : VECTOR (LENGTH=',VL_DIM,')'
  ELSE
     WRITE(*,*) ' MODE             : SCALAR'
  END IF
!
  WRITE(*,*) ' DE-INDEXING MODE :',I_LU_DI
!
  WRITE(*,*) ' ICNTRL           : ',icntrl
  WRITE(*,*) ' RCNTRL           : ',rcntrl
!
!  NOTE: THIS IS ONLY MEANINGFUL FOR VECTORIZED (kp4) ROSENBROCK- METHODS
  IF (L_VECTOR) THEN
     IF (l_fixed_step) THEN
        WRITE(*,*) ' TIME STEPS       : FIXED (',t_steps(1:nfsteps),')'
     ELSE
        WRITE(*,*) ' TIME STEPS       : AUTOMATIC'
     END IF
  ELSE
     WRITE(*,*) ' TIME STEPS       : AUTOMATIC '//&
          &'(t_steps (CTRL_KPP) ignored in SCALAR MODE)'
  END IF
!  mz_pj_20070531-

  status = 0

CONTAINS

  SUBROUTINE kpp_read_nml_ctrl(status, iou)

!  READ MECCA NAMELIST, CHECK IT, AND INITIALIZE GLOBAL VARIABLES
!
!  Author: Astrid Kerkweg,  MPICH, June 2007
!          Patrick Joeckel, MPICH, June 2007



!  I/O
    INTEGER, INTENT(OUT) :: status  !  error status
    INTEGER, INTENT(IN)  :: iou     !  logical I/O unit

!  LOCAL
    LOGICAL :: lex    !  file exists?
    INTEGER :: fstat  !  file status
    CHARACTER(LEN=*),PARAMETER :: substr = 'kpp_read_nml_ctrl'

    NAMELIST /CTRL_KPP/ icntrl, rcntrl, t_steps

!  INITIALIZE
    status = 1  !  error

!  INPUT NAMELIST
    CALL read_nml_open(lex,substr,iou,'CTRL_KPP',modstr)
    IF (.not.lex) RETURN     !  <modstr>.nml does not exist

    READ(iou, NML=CTRL_KPP, IOSTAT=fstat)
    CALL read_nml_check(fstat,substr,iou,'CTRL_KPP',modstr)
    IF (fstat /= 0) RETURN   !  error while reading namelist

    WRITE(*,*) 'solver-specific method:      icntrl(3) = ',icntrl(3)
    WRITE(*,*) 'max. number of kpp-substeps: icntrl(4) = ',icntrl(4)

    CALL read_nml_close(substr, iou, modstr)
    status = 0  !  no error

  END SUBROUTINE kpp_read_nml_ctrl

END SUBROUTINE initialize_kpp_ctrl
 
  ELEMENTAL REAL(kind=dp) FUNCTION k_arr (k_298,tdep,temp)
!  Arrhenius function

    REAL,     INTENT(IN) :: k_298  !  k at T = 298.15K
    REAL,     INTENT(IN) :: tdep   !  temperature dependence
    REAL(kind=dp), INTENT(IN) :: temp   !  temperature

    INTRINSIC EXP

    k_arr = k_298 *EXP(tdep*(1._dp/temp- 3.3540E-3_dp)) !  1/298.15=3.3540e-3

  END FUNCTION k_arr
 
      SUBROUTINE WCOPY(N,X,incX,Y,incY)
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       copies a vector, x, to a vector, y:  y <-  x
!       only for incX=incY=1
!       after BLAS
!       replace this by the function from the optimized BLAS implementation:
!           CALL  SCOPY(N,X,1,Y,1)   or   CALL  DCOPY(N,X,1,Y,1)
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       USE messy_scav_i_kpp_Precision
      
      INTEGER  :: i,incX,incY,M,MP1,N
      REAL(kind=dp) :: X(N),Y(N)

      IF (N.LE.0) RETURN

      M = MOD(N,8)
      IF( M .NE. 0)THEN
        DO i = 1,M
          Y(i) = X(i)
        END DO
        IF( N .LT. 8)RETURN
      END IF    
      MP1 = M+ 1
      DO i = MP1,N,8
        Y(i) = X(i)
        Y(i +  1) = X(i +  1)
        Y(i +  2) = X(i +  2)
        Y(i +  3) = X(i +  3)
        Y(i +  4) = X(i +  4)
        Y(i +  5) = X(i +  5)
        Y(i +  6) = X(i +  6)
        Y(i +  7) = X(i +  7)
      END DO

      END SUBROUTINE WCOPY
 
      SUBROUTINE WSCAL(N,Alpha,X,incX)
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       constant times a vector: x(1:N) <-  Alpha*x(1:N)
!       only for incX=incY=1
!       after BLAS
!       replace this by the function from the optimized BLAS implementation:
!           CALL SSCAL(N,Alpha,X,1) or  CALL DSCAL(N,Alpha,X,1)
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      INTEGER  :: i,incX,M,MP1,N
      REAL(kind=dp)  :: X(N),Alpha
      REAL(kind=dp), PARAMETER  :: ZERO=0.0_dp, ONE=1.0_dp

      IF (Alpha .EQ. ONE) RETURN
      IF (N .LE. 0) RETURN

      M = MOD(N,5)
      IF( M .NE. 0)THEN
        IF (Alpha .EQ. (- ONE))THEN
          DO i = 1,M
            X(i) = - X(i)
          END DO
        ELSEIF (Alpha .EQ. ZERO) THEN
          DO i = 1,M
            X(i) = ZERO
          END DO
        ELSE
          DO i = 1,M
            X(i) = Alpha*X(i)
          END DO
        END IF
        IF( N .LT. 5)RETURN
      END IF
      MP1 = M +  1
      IF (Alpha .EQ. (- ONE))THEN
        DO i = MP1,N,5
          X(i)     = - X(i)
          X(i +  1) = - X(i +  1)
          X(i +  2) = - X(i +  2)
          X(i +  3) = - X(i +  3)
          X(i +  4) = - X(i +  4)
        END DO
      ELSEIF (Alpha .EQ. ZERO) THEN
        DO i = MP1,N,5
          X(i)     = ZERO
          X(i +  1) = ZERO
          X(i +  2) = ZERO
          X(i +  3) = ZERO
          X(i +  4) = ZERO
        END DO
      ELSE
        DO i = MP1,N,5
          X(i)     = Alpha*X(i)
          X(i +  1) = Alpha*X(i +  1)
          X(i +  2) = Alpha*X(i +  2)
          X(i +  3) = Alpha*X(i +  3)
          X(i +  4) = Alpha*X(i +  4)
        END DO
      END IF

      END SUBROUTINE WSCAL
 
      SUBROUTINE WAXPY(N,Alpha,X,incX,Y,incY)
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!       constant times a vector plus a vector: y <-  y +  Alpha*x
!       only for incX=incY=1
!       after BLAS
!       replace this by the function from the optimized BLAS implementation:
!           CALL SAXPY(N,Alpha,X,1,Y,1) or  CALL DAXPY(N,Alpha,X,1,Y,1)
!  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

      INTEGER  :: i,incX,incY,M,MP1,N
      REAL(kind=dp) :: X(N),Y(N),Alpha
      REAL(kind=dp), PARAMETER :: ZERO = 0.0_dp

      IF (Alpha .EQ. ZERO) RETURN
      IF (N .LE. 0) RETURN

      M = MOD(N,4)
      IF( M .NE. 0)THEN
        DO i = 1,M
          Y(i) = Y(i) +  Alpha*X(i)
        END DO
        IF( N .LT. 4)RETURN
      END IF
      MP1 = M +  1
      DO i = MP1,N,4
        Y(i) = Y(i) +  Alpha*X(i)
        Y(i +  1) = Y(i +  1) +  Alpha*X(i +  1)
        Y(i +  2) = Y(i +  2) +  Alpha*X(i +  2)
        Y(i +  3) = Y(i +  3) +  Alpha*X(i +  3)
      END DO
      
      END SUBROUTINE WAXPY
 
SUBROUTINE Rosenbrock(Y,Tstart,Tend, &
           AbsTol,RelTol,            &
           RCNTRL,ICNTRL,RSTATUS,ISTATUS,IERR)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!    Solves the system y'=F(t,y) using a Rosenbrock method defined by:
!
!       G = 1/(H*gamma(1))-  Jac(t0,Y0)
!       T_i = t0 +  Alpha(i)*H
!       Y_i = Y0 +  \sum_{j=1}^{i- 1} A(i,j)*K_j
!       G *K_i = Fun( T_i, Y_i)+  \sum_{j=1}^S C(i,j)/H *K_j +
!           gamma(i)*dF/dT(t0, Y0)
!       Y1 = Y0 +  \sum_{j=1}^S M(j)*K_j
!
!      For details on Rosenbrock methods and their implementation consult:
!        E. Hairer and G. Wanner
!        "Solving ODEs II. Stiff and differential- algebraic problems".
!        Springer series in computational mathematics, Springer- Verlag, 1996.
!      The codes contained in the book inspired this implementation.
!
!      (C)  Adrian Sandu, August 2004
!      Virginia Polytechnic Institute and State University
!      Contact: sandu@cs.vt.edu
!      This implementation is part of KPP -  the Kinetic PreProcessor
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!  ~~~>   INPUT ARGUMENTS:
!
!  -      Y(NVAR)    = vector of initial conditions (at T=Tstart)
!  -     [Tstart,Tend]  = time range of integration
!       (if Tstart>Tend the integration is performed backwards in time)
!  -     RelTol, AbsTol = user precribed accuracy
!  -  SUBROUTINE  Fun( T, Y, Ydot)= ODE function,
!                       returns Ydot = Y' = F(T,Y)
!  -  SUBROUTINE  Jac( T, Y, Jcb)= Jacobian of the ODE function,
!                         returns Jcb = dFun/dY
!  -     ICNTRL(1:20)    = integer inputs parameters
!  -     RCNTRL(1:20)    = real inputs parameters
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!  ~~~>     OUTPUT ARGUMENTS:
!
!  -     Y(NVAR)    - > vector of final states (at T- >Tend)
!  -     ISTATUS(1:20)   - > integer output parameters
!  -     RSTATUS(1:20)   - > real output parameters
!  -     IERR            - > job status upon return
!                          success (positive value) or
!                          failure (negative value)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!  ~~~>     INPUT PARAMETERS:
!
!      Note: For input parameters equal to zero the default values of the
!         corresponding variables are used.
!
!      ICNTRL(1) = 1: F = F(y)   Independent of T (AUTONOMOUS)
!                = 0: F = F(t,y) Depends on T (NON- AUTONOMOUS)
!
!      ICNTRL(2) = 0: AbsTol, RelTol are NVAR- dimensional vectors
!                = 1: AbsTol, RelTol are scalars
!
!      ICNTRL(3)  - > selection of a particular Rosenbrock method
!          = 0 :  default method is Rodas3
!          = 1 :  method is  Ros2
!          = 2 :  method is  Ros3
!          = 3 :  method is  Ros4
!          = 4 :  method is  Rodas3
!          = 5:   method is  Rodas4
!
!      ICNTRL(4)  - > maximum number of integration steps
!          For ICNTRL(4)=0) the default value of 100000 is used
!
!      RCNTRL(1)  - > Hmin, lower bound for the integration step size
!            It is strongly recommended to keep Hmin = ZERO
!      RCNTRL(2)  - > Hmax, upper bound for the integration step size
!      RCNTRL(3)  - > Hstart, starting value for the integration step size
!
!      RCNTRL(4)  - > FacMin, lower bound on step decrease factor (default=0.2)
!      RCNTRL(5)  - > FacMax, upper bound on step increase factor (default=6)
!      RCNTRL(6)  - > FacRej, step decrease factor after multiple rejections
!              (default=0.1)
!      RCNTRL(7)  - > FacSafe, by which the new step is slightly smaller
!           than the predicted value  (default=0.9)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
!  ~~~>     OUTPUT PARAMETERS:
!
!      Note: each call to Rosenbrock adds the current no. of fcn calls
!        to previous value of ISTATUS(1), and similar for the other params.
!        Set ISTATUS(1:20) = 0 before call to avoid this accumulation.
!
!      ISTATUS(1) = No. of function calls
!      ISTATUS(2) = No. of jacobian calls
!      ISTATUS(3) = No. of steps
!      ISTATUS(4) = No. of accepted steps
!      ISTATUS(5) = No. of rejected steps (except at the beginning)
!      ISTATUS(6) = No. of LU decompositions
!      ISTATUS(7) = No. of forward/backward substitutions
!      ISTATUS(8) = No. of singular matrix decompositions
!
!      RSTATUS(1)  - > Texit, the time corresponding to the
!                     computed Y upon return
!      RSTATUS(2)  - > Hexit, last accepted step before exit
!      For multiple restarts, use Hexit as Hstart in the following run
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


!  ~~~>  Arguments
   REAL(kind=dp), INTENT(INOUT) :: Y(NVAR)
   REAL(kind=dp), INTENT(IN)   :: Tstart,Tend
   REAL(kind=dp), INTENT(IN)   :: AbsTol(NVAR),RelTol(NVAR)
   INTEGER, INTENT(IN)    :: ICNTRL(20)
   REAL(kind=dp), INTENT(IN)   :: RCNTRL(20)
   INTEGER, INTENT(INOUT) :: ISTATUS(20)
   REAL(kind=dp), INTENT(INOUT) :: RSTATUS(20)
   INTEGER, INTENT(OUT)   :: IERR
!  ~~~>  The method parameters
   INTEGER, PARAMETER :: Smax = 6
   INTEGER  :: Method, ros_S
   REAL(kind=dp), DIMENSION(Smax) :: ros_M, ros_E, ros_Alpha, ros_Gamma
   REAL(kind=dp), DIMENSION(Smax*(Smax- 1)/2) :: ros_A, ros_C
   REAL(kind=dp) :: ros_ELO
   LOGICAL, DIMENSION(Smax) :: ros_NewF
   CHARACTER(LEN=12) :: ros_Name
!  ~~~>  Local variables
   REAL(kind=dp) :: Roundoff, FacMin, FacMax, FacRej, FacSafe
   REAL(kind=dp) :: Hmin, Hmax, Hstart, Hexit
   REAL(kind=dp) :: Texit
   INTEGER :: i, UplimTol, Max_no_steps
   LOGICAL :: Autonomous, VectorTol
!  ~~~>   Parameters
   REAL(kind=dp), PARAMETER :: ZERO = 0.0_dp, ONE  = 1.0_dp
   REAL(kind=dp), PARAMETER :: DeltaMin = 1.0E-5_dp

!  ~~~>  Initialize statistics
   Nfun = ISTATUS(ifun)
   Njac = ISTATUS(ijac)
   Nstp = ISTATUS(istp)
   Nacc = ISTATUS(iacc)
   Nrej = ISTATUS(irej)
   Ndec = ISTATUS(idec)
   Nsol = ISTATUS(isol)
   Nsng = ISTATUS(isng)

!  ~~~>  Autonomous or time dependent ODE. Default is time dependent.
   Autonomous = .NOT.(ICNTRL(1) == 0)

!  ~~~>  For Scalar tolerances (ICNTRL(2).NE.0)  the code uses AbsTol(1) and RelTol(1)
!     For Vector tolerances (ICNTRL(2) == 0) the code uses AbsTol(1:NVAR) and RelTol(1:NVAR)
   IF (ICNTRL(2) == 0) THEN
      VectorTol = .TRUE.
         UplimTol  = NVAR
   ELSE
      VectorTol = .FALSE.
         UplimTol  = 1
   END IF

!  ~~~>  The particular Rosenbrock method chosen
   IF (ICNTRL(3) == 0) THEN
      Method = 4
   ELSEIF((ICNTRL(3) >= 1).AND.(ICNTRL(3) <= 5))THEN
      Method = ICNTRL(3)
   ELSE
      PRINT *,'User-selected Rosenbrock method: ICNTRL(3)=',Method
      CALL ros_ErrorMsg(- 2,Tstart,ZERO,IERR)
      RETURN
   END IF

!  ~~~>   The maximum number of steps admitted
   IF (ICNTRL(4) == 0) THEN
      Max_no_steps = 100000
   ELSEIF (ICNTRL(4) > 0) THEN
      Max_no_steps=ICNTRL(4)
   ELSE
      PRINT *,'User-selected max no. of steps: ICNTRL(4)=',ICNTRL(4)
      CALL ros_ErrorMsg(- 1,Tstart,ZERO,IERR)
      RETURN
   END IF

!  ~~~>  Unit roundoff (1+ Roundoff>1)
   Roundoff = WLAMCH('E')

!  ~~~>  Lower bound on the step size: (positive value)
   IF (RCNTRL(1) == ZERO) THEN
      Hmin = ZERO
   ELSEIF (RCNTRL(1) > ZERO) THEN
      Hmin = RCNTRL(1)
   ELSE
      PRINT *,'User-selected Hmin: RCNTRL(1)=',RCNTRL(1)
      CALL ros_ErrorMsg(- 3,Tstart,ZERO,IERR)
      RETURN
   END IF
!  ~~~>  Upper bound on the step size: (positive value)
   IF (RCNTRL(2) == ZERO) THEN
      Hmax = ABS(Tend-Tstart)
   ELSEIF (RCNTRL(2) > ZERO) THEN
      Hmax = MIN(ABS(RCNTRL(2)),ABS(Tend-Tstart))
   ELSE
      PRINT *,'User-selected Hmax: RCNTRL(2)=',RCNTRL(2)
      CALL ros_ErrorMsg(- 3,Tstart,ZERO,IERR)
      RETURN
   END IF
!  ~~~>  Starting step size: (positive value)
   IF (RCNTRL(3) == ZERO) THEN
      Hstart = MAX(Hmin,DeltaMin)
   ELSEIF (RCNTRL(3) > ZERO) THEN
      Hstart = MIN(ABS(RCNTRL(3)),ABS(Tend-Tstart))
   ELSE
      PRINT *,'User-selected Hstart: RCNTRL(3)=',RCNTRL(3)
      CALL ros_ErrorMsg(- 3,Tstart,ZERO,IERR)
      RETURN
   END IF
!  ~~~>  Step size can be changed s.t.  FacMin < Hnew/Hexit < FacMax
   IF (RCNTRL(4) == ZERO) THEN
      FacMin = 0.2_dp
   ELSEIF (RCNTRL(4) > ZERO) THEN
      FacMin = RCNTRL(4)
   ELSE
      PRINT *,'User-selected FacMin: RCNTRL(4)=',RCNTRL(4)
      CALL ros_ErrorMsg(- 4,Tstart,ZERO,IERR)
      RETURN
   END IF
   IF (RCNTRL(5) == ZERO) THEN
      FacMax = 6.0_dp
   ELSEIF (RCNTRL(5) > ZERO) THEN
      FacMax = RCNTRL(5)
   ELSE
      PRINT *,'User-selected FacMax: RCNTRL(5)=',RCNTRL(5)
      CALL ros_ErrorMsg(- 4,Tstart,ZERO,IERR)
      RETURN
   END IF
!  ~~~>   FacRej: Factor to decrease step after 2 succesive rejections
   IF (RCNTRL(6) == ZERO) THEN
      FacRej = 0.1_dp
   ELSEIF (RCNTRL(6) > ZERO) THEN
      FacRej = RCNTRL(6)
   ELSE
      PRINT *,'User-selected FacRej: RCNTRL(6)=',RCNTRL(6)
      CALL ros_ErrorMsg(- 4,Tstart,ZERO,IERR)
      RETURN
   END IF
!  ~~~>   FacSafe: Safety Factor in the computation of new step size
   IF (RCNTRL(7) == ZERO) THEN
      FacSafe = 0.9_dp
   ELSEIF (RCNTRL(7) > ZERO) THEN
      FacSafe = RCNTRL(7)
   ELSE
      PRINT *,'User-selected FacSafe: RCNTRL(7)=',RCNTRL(7)
      CALL ros_ErrorMsg(- 4,Tstart,ZERO,IERR)
      RETURN
   END IF
!  ~~~>  Check if tolerances are reasonable
    DO i=1,UplimTol
      IF((AbsTol(i) <= ZERO) .OR. (RelTol(i) <= 10.0_dp*Roundoff) &
         .OR. (RelTol(i) >= 1.0_dp))THEN
        PRINT *,' AbsTol(',i,') = ',AbsTol(i)
        PRINT *,' RelTol(',i,') = ',RelTol(i)
        CALL ros_ErrorMsg(- 5,Tstart,ZERO,IERR)
        RETURN
      END IF
    END DO


!  ~~~>   Initialize the particular Rosenbrock method
   SELECT CASE (Method)
     CASE (1)
       CALL Ros2(ros_S, ros_A, ros_C, ros_M, ros_E,   &
          ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
     CASE (2)
       CALL Ros3(ros_S, ros_A, ros_C, ros_M, ros_E,   &
          ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
     CASE (3)
       CALL Ros4(ros_S, ros_A, ros_C, ros_M, ros_E,   &
          ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
     CASE (4)
       CALL Rodas3(ros_S, ros_A, ros_C, ros_M, ros_E, &
          ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
     CASE (5)
       CALL Rodas4(ros_S, ros_A, ros_C, ros_M, ros_E, &
          ros_Alpha, ros_Gamma, ros_NewF, ros_ELO, ros_Name)
     CASE DEFAULT
       PRINT *,'Unknown Rosenbrock method: ICNTRL(3)=',Method
       CALL ros_ErrorMsg(- 2,Tstart,ZERO,IERR)
       RETURN
   END SELECT

!  ~~~>  CALL Rosenbrock method
   CALL ros_Integrator(Y,Tstart,Tend,Texit,      &
        AbsTol, RelTol,                          &
!    Rosenbrock method coefficients
        ros_S, ros_M, ros_E, ros_A, ros_C,       &
        ros_Alpha, ros_Gamma, ros_ELO, ros_NewF, &
!    Integration parameters
        Autonomous, VectorTol, Max_no_steps,     &
        Roundoff, Hmin, Hmax, Hstart, Hexit,     &
        FacMin, FacMax, FacRej, FacSafe,         &
!    Error indicator
        IERR)


!  ~~~>  Collect run statistics
   ISTATUS(ifun) = Nfun
   ISTATUS(ijac) = Njac
   ISTATUS(istp) = Nstp
   ISTATUS(iacc) = Nacc
   ISTATUS(irej) = Nrej
   ISTATUS(idec) = Ndec
   ISTATUS(isol) = Nsol
   ISTATUS(isng) = Nsng
!  ~~~> Last T and H
   RSTATUS(itexit) = Texit
   RSTATUS(ihexit) = Hexit

!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CONTAINS  !   SUBROUTINES internal to Rosenbrock
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 SUBROUTINE ros_ErrorMsg(Code,T,H,IERR)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!      Handles all error messages
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   REAL(kind=dp), INTENT(IN) :: T, H
   INTEGER, INTENT(IN)  :: Code
   INTEGER, INTENT(OUT) :: IERR

   IERR = Code
   PRINT *, &
     'Forced exit from Rosenbrock due to the following error:'
   IF ((Code>=- 8).AND.(Code<=- 1))THEN
     PRINT *, IERR_NAMES(Code)
   ELSE
     PRINT *,'Unknown Error code: ',Code
   ENDIF

   PRINT *, "T=", T, "and H=", H

 END SUBROUTINE ros_ErrorMsg

!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 SUBROUTINE ros_Integrator (Y, Tstart, Tend, T,     &
        AbsTol, RelTol,                          &
!  ~~~> Rosenbrock method coefficients
        ros_S, ros_M, ros_E, ros_A, ros_C,       &
        ros_Alpha, ros_Gamma, ros_ELO, ros_NewF, &
!  ~~~> Integration parameters
        Autonomous, VectorTol, Max_no_steps,     &
        Roundoff, Hmin, Hmax, Hstart, Hexit,     &
        FacMin, FacMax, FacRej, FacSafe,         &
!  ~~~> Error indicator
        IERR)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     Template for the implementation of a generic Rosenbrock method
!        defined by ros_S (no of stages)
!        and its coefficients ros_{A,C,M,E,Alpha,Gamma}
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


!  ~~~> Input: the initial condition at Tstart; Output: the solution at T
   REAL(kind=dp), INTENT(INOUT) :: Y(NVAR)
!  ~~~> Input: integration interval
   REAL(kind=dp), INTENT(IN) :: Tstart,Tend
!  ~~~> Output: time at which the solution is returned (T=Tend if success)
   REAL(kind=dp), INTENT(OUT) ::  T
!  ~~~> Input: tolerances
   REAL(kind=dp), INTENT(IN) ::  AbsTol(NVAR), RelTol(NVAR)
!  ~~~> Input: The Rosenbrock method parameters
   INTEGER, INTENT(IN) ::  ros_S
   REAL(kind=dp), INTENT(IN) :: ros_M(ros_S), ros_E(ros_S),  &
       ros_Alpha(ros_S), ros_A(ros_S*(ros_S- 1)/2), &
       ros_Gamma(ros_S), ros_C(ros_S*(ros_S- 1)/2), ros_ELO
   LOGICAL, INTENT(IN) :: ros_NewF(ros_S)
!  ~~~> Input: integration parameters
   LOGICAL, INTENT(IN) :: Autonomous, VectorTol
   REAL(kind=dp), INTENT(IN) :: Hstart, Hmin, Hmax
   INTEGER, INTENT(IN) :: Max_no_steps
   REAL(kind=dp), INTENT(IN) :: Roundoff, FacMin, FacMax, FacRej, FacSafe
!  ~~~> Output: last accepted step
   REAL(kind=dp), INTENT(OUT) :: Hexit
!  ~~~> Output: Error indicator
   INTEGER, INTENT(OUT) :: IERR
!   ~~~~ Local variables
   REAL(kind=dp) :: Ynew(NVAR), Fcn0(NVAR), Fcn(NVAR)
   REAL(kind=dp) :: K(NVAR*ros_S), dFdT(NVAR)
# 2685

   REAL(kind=dp) :: Jac0(LU_NONZERO), Ghimj(LU_NONZERO)

   REAL(kind=dp) :: H, Hnew, HC, HG, Fac, Tau
   REAL(kind=dp) :: Err, Yerr(NVAR)
   INTEGER :: Pivot(NVAR), Direction, ioffset, j, istage
   LOGICAL :: RejectLastH, RejectMoreH, Singular
!  ~~~>  Local parameters
   REAL(kind=dp), PARAMETER :: ZERO = 0.0_dp, ONE  = 1.0_dp
   REAL(kind=dp), PARAMETER :: DeltaMin = 1.0E-5_dp
!  ~~~>  Locally called functions
!      REAL(kind=dp) WLAMCH
!      EXTERNAL WLAMCH
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


!  ~~~>  Initial preparations
   T = Tstart
   Hexit = 0.0_dp
   H = MIN(Hstart,Hmax)
   IF (ABS(H) <= 10.0_dp*Roundoff) H = DeltaMin

   IF (Tend  >=  Tstart) THEN
     Direction = + 1
   ELSE
     Direction = - 1
   END IF

   RejectLastH=.FALSE.
   RejectMoreH=.FALSE.

!  ~~~> Time loop begins below

TimeLoop: DO WHILE((Direction > 0).AND.((T- Tend)+ Roundoff <= ZERO) &
       .OR. (Direction < 0).AND.((Tend-T)+ Roundoff <= ZERO))

   IF(Nstp > Max_no_steps)THEN   !  Too many steps
      CALL ros_ErrorMsg(- 6,T,H,IERR)
      RETURN
   END IF
   IF(((T+ H ==  T)))THEN   !  Step size too small
      CALL ros_ErrorMsg(- 7,T,H,IERR)
      RETURN
   END IF

!  ~~~>  Limit H if necessary to avoid going beyond Tend
   Hexit = H
   H = MIN(H,ABS(Tend-T))

!  ~~~>   Compute the function at current time
   CALL FunTemplate(T,Y,Fcn0)

!  ~~~>  Compute the function derivative with respect to T
   IF (.NOT.Autonomous) THEN
      CALL ros_FunTimeDerivative(T, Roundoff, Y, &
                Fcn0, dFdT)
   END IF

!  ~~~>   Compute the Jacobian at current time
   CALL JacTemplate(T,Y,Jac0)

!  ~~~>  Repeat step calculation until current step accepted
UntilAccepted: DO

   CALL ros_PrepareMatrix(H,Direction,ros_Gamma(1), &
          Jac0,Ghimj,Pivot,Singular)
   IF (Singular) THEN  !  More than 5 consecutive failed decompositions
       CALL ros_ErrorMsg(- 8,T,H,IERR)
       RETURN
   END IF

!  ~~~>   Compute the stages
Stage: DO istage = 1, ros_S

!  Current istage offset. Current istage vector is K(ioffset+ 1:ioffset+ NVAR)
       ioffset = NVAR*(istage-1)

!  For the 1st istage the function has been computed previously
       IF(istage == 1)THEN
!           CALL WCOPY(NVAR,Fcn0,1,Fcn,1)
         Fcn(1:NVAR) = Fcn0(1:NVAR) 
!  istage>1 and a new function evaluation is needed at the current istage
       ELSEIF(ros_NewF(istage))THEN
!           CALL WCOPY(NVAR,Y,1,Ynew,1)
         Ynew(1:NVAR) = Y(1:NVAR)
         DO j = 1, istage-1
!             CALL WAXPY(NVAR,ros_A((istage-1)*(istage-2)/2+ j), &
!              K(NVAR*(j- 1)+ 1),1,Ynew,1)
           Ynew(1:NVAR) = Ynew(1:NVAR) +  K(NVAR*(j- 1)+ 1:NVAR*j) &
                        *ros_A((istage-1)*(istage-2)/2+ j)
         END DO
         Tau = T +  ros_Alpha(istage)*Direction*H
         CALL FunTemplate(Tau,Ynew,Fcn)
       END IF  !  if istage == 1 elseif ros_NewF(istage)
!         CALL WCOPY(NVAR,Fcn,1,K(ioffset+ 1),1)
       K(ioffset+ 1:ioffset+ NVAR) = Fcn(1:NVAR)
       DO j = 1, istage-1
         HC = ros_C((istage-1)*(istage-2)/2+ j)/(Direction*H)
!           CALL WAXPY(NVAR,HC,K(NVAR*(j- 1)+ 1),1,K(ioffset+ 1),1)
         K(ioffset+ 1:ioffset+ NVAR) = K(ioffset+ 1:ioffset+ NVAR) +  &
           K(NVAR*(j- 1)+ 1:NVAR*j) *HC
       END DO
       IF ((.NOT. Autonomous).AND.(ros_Gamma(istage).NE.ZERO))THEN
         HG = Direction*H*ros_Gamma(istage)
!           CALL WAXPY(NVAR,HG,dFdT,1,K(ioffset+ 1),1)
         K(ioffset+ 1:ioffset+ NVAR) = K(ioffset+ 1:ioffset+ NVAR) +  &
           dFdT(1:NVAR) *HG
       END IF
       CALL ros_Solve(Ghimj, Pivot, K(ioffset+ 1))

   END DO Stage


!  ~~~>  Compute the new solution
!     CALL WCOPY(NVAR,Y,1,Ynew,1)
   YNEW(1:NVAR) = Y(1:NVAR)
   Yerr(1:NVAR) = ZERO  !  op_pj_20150622: moved to here according to BULL
   DO j=1,ros_S
!           CALL WAXPY(NVAR,ros_M(j),K(NVAR*(j- 1)+ 1),1,Ynew,1)
         Ynew(1:NVAR) = Ynew(1:NVAR) +  &
                        K(NVAR*(j- 1)+ 1:NVAR*j) *ros_m(j)
!    !  $   END DO   !   op_pj_20150622: loop fusion according to BULL

!  ~~~>  Compute the error estimation
!     CALL WSCAL(NVAR,ZERO,Yerr,1)
!    !  $   Yerr(1:NVAR) = ZERO   !   op_pj_20150622: moved to above according to BULL
!    !  $   DO j=1,ros_S   !   op_pj_20150622: loop fusion according to BULL
!       CALL WAXPY(NVAR,ros_E(j),K(NVAR*(j- 1)+ 1),1,Yerr,1)
     Yerr(1:NVAR) = Yerr(1:NVAR) +  &
                    K(NVAR*(j- 1)+ 1:NVAR*j) *ros_E(j)
   END DO
   Err = ros_ErrorNorm(Y, Ynew, Yerr, AbsTol, RelTol, VectorTol)

!  ~~~> New step size is bounded by FacMin <= Hnew/H <= FacMax
   Fac  = MIN(FacMax,MAX(FacMin,FacSafe/Err**(ONE/ros_ELO)))
   Hnew = H*Fac

!  ~~~>  Check the error magnitude and adjust step size
   Nstp = Nstp+ 1
   IF((Err <= ONE).OR.(H <= Hmin))THEN   ! ~~~> Accept step
      Nacc = Nacc+ 1
!        CALL WCOPY(NVAR,Ynew,1,Y,1)
      Y(1:NVAR) = MAX(Ynew(1:NVAR),ZERO)
      T = T +  Direction*H
      Hnew = MAX(Hmin,MIN(Hnew,Hmax))
      IF (RejectLastH) THEN   !  No step size increase after a rejected step
         Hnew = MIN(Hnew,H)
      END IF
      RejectLastH = .FALSE.
      RejectMoreH = .FALSE.
      H = Hnew
      EXIT UntilAccepted  !  EXIT THE LOOP: WHILE STEP NOT ACCEPTED
   ELSE            ! ~~~> Reject step
      IF (RejectMoreH) THEN
         Hnew = H*FacRej
      END IF
      RejectMoreH = RejectLastH
      RejectLastH = .TRUE.
      H = Hnew
      IF (Nacc >= 1) THEN
         Nrej = Nrej+ 1
      END IF
   END IF  !  Err <= 1

   END DO UntilAccepted

   END DO TimeLoop

!  ~~~> Succesful exit
   IERR = 1   ! ~~~> The integration was successful

  END SUBROUTINE ros_Integrator


!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  REAL(kind=dp) FUNCTION ros_ErrorNorm(Y, Ynew, Yerr, &
               AbsTol, RelTol, VectorTol)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  ~~~> Computes the "scaled norm" of the error vector Yerr
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!   Input arguments
   REAL(kind=dp), INTENT(IN) :: Y(NVAR), Ynew(NVAR), &
          Yerr(NVAR), AbsTol(NVAR), RelTol(NVAR)
   LOGICAL, INTENT(IN) ::  VectorTol
!   Local variables
   REAL(kind=dp) :: Err, Scale, Ymax
   INTEGER  :: i
   REAL(kind=dp), PARAMETER :: ZERO = 0.0_dp

   Err = ZERO
   DO i=1,NVAR
     Ymax = MAX(ABS(Y(i)),ABS(Ynew(i)))
     IF (VectorTol) THEN
       Scale = AbsTol(i)+ RelTol(i)*Ymax
     ELSE
       Scale = AbsTol(1)+ RelTol(1)*Ymax
     END IF
     Err = Err+ (Yerr(i)/Scale)**2
   END DO
   Err  = SQRT(Err/NVAR)

   ros_ErrorNorm = Err

  END FUNCTION ros_ErrorNorm


!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE ros_FunTimeDerivative(T, Roundoff, Y, &
                Fcn0, dFdT)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  ~~~> The time partial derivative of the function by finite differences
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!  ~~~> Input arguments
   REAL(kind=dp), INTENT(IN) :: T, Roundoff, Y(NVAR), Fcn0(NVAR)
!  ~~~> Output arguments
   REAL(kind=dp), INTENT(OUT) :: dFdT(NVAR)
!  ~~~> Local variables
   REAL(kind=dp) :: Delta
   REAL(kind=dp), PARAMETER :: ONE = 1.0_dp, DeltaMin = 1.0E-6_dp

   Delta = SQRT(Roundoff)*MAX(DeltaMin,ABS(T))
   CALL FunTemplate(T+ Delta,Y,dFdT)
!     CALL WAXPY(NVAR,(- ONE),Fcn0,1,dFdT,1)
   dFdt(1:NVAR) = dFdt(1:NVAR) -  ONE *FcN0(1:NVAR)
!     CALL WSCAL(NVAR,(ONE/Delta),dFdT,1)
   dFDT(1:NVAR) = dFDT(1:NVAR) *(ONE/Delta)
  END SUBROUTINE ros_FunTimeDerivative


!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE ros_PrepareMatrix(H, Direction, gam, &
             Jac0, Ghimj, Pivot, Singular)
!   - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -
!    Prepares the LHS matrix for stage calculations
!    1.  Construct Ghimj = 1/(H*ham) -  Jac0
!        "(Gamma H) Inverse Minus Jacobian"
!    2.  Repeat LU decomposition of Ghimj until successful.
!         - half the step size if LU decomposition fails and retry
!         - exit after 5 consecutive fails
!   - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -  - - -

!  ~~~> Input arguments
# 2931

   REAL(kind=dp), INTENT(IN) ::  Jac0(LU_NONZERO)

   REAL(kind=dp), INTENT(IN) ::  gam
   INTEGER, INTENT(IN) ::  Direction
!  ~~~> Output arguments
# 2939

   REAL(kind=dp), INTENT(OUT) :: Ghimj(LU_NONZERO)

   LOGICAL, INTENT(OUT) ::  Singular
   INTEGER, INTENT(OUT) ::  Pivot(NVAR)
!  ~~~> Inout arguments
   REAL(kind=dp), INTENT(INOUT) :: H    !  step size is decreased when LU fails
!  ~~~> Local variables
   INTEGER  :: i, ising, Nconsecutive
   REAL(kind=dp) :: ghinv
   REAL(kind=dp), PARAMETER :: ONE  = 1.0_dp, HALF = 0.5_dp

   Nconsecutive = 0
   Singular = .TRUE.

   DO WHILE (Singular)

!  ~~~>    Construct Ghimj = 1/(H*gam) -  Jac0
# 2966

!       CALL WCOPY(LU_NONZERO,Jac0,1,Ghimj,1)
     Ghimj(1:LU_NONZERO) = JAC0(1:LU_NONZERO)
!       CALL WSCAL(LU_NONZERO,(- ONE),Ghimj,1)
     Ghimj(1:LU_NONZERO) = (- ONE) *Ghimj(1:LU_NONZERO) 
     ghinv = ONE/(Direction*H*gam)
     DO i=1,NVAR
       Ghimj(LU_DIAG(i))= Ghimj(LU_DIAG(i))+ ghinv
     END DO

!  ~~~>    Compute LU decomposition
     CALL ros_Decomp( Ghimj, Pivot, ising)
     IF (ising == 0) THEN
!  ~~~>    If successful done
        Singular = .FALSE.
     ELSE  !  ising .ne. 0
!  ~~~>    If unsuccessful half the step size; if 5 consecutive fails then return
        Nsng = Nsng+ 1
        Nconsecutive = Nconsecutive+1
        Singular = .TRUE.
        PRINT*,'Warning: LU Decomposition returned ising = ',ising
        IF (Nconsecutive <= 5) THEN  !  Less than 5 consecutive failed decompositions
           H = H*HALF
        ELSE   !  More than 5 consecutive failed decompositions
           RETURN
        END IF   !  Nconsecutive
      END IF     !  ising

   END DO  !  WHILE Singular

  END SUBROUTINE ros_PrepareMatrix


!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE ros_Decomp( A, Pivot, ising)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Template for the LU decomposition
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  ~~~> Inout variables
   REAL(kind=dp), INTENT(INOUT) :: A(LU_NONZERO)
!  ~~~> Output variables
   INTEGER, INTENT(OUT) :: Pivot(NVAR), ising

# 3011

   CALL KppDecomp(A, ising)
   Pivot(1) = 1

   Ndec = Ndec +  1

  END SUBROUTINE ros_Decomp


!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE ros_Solve( A, Pivot, b)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Template for the forward/backward substitution (using pre-computed LU decomposition)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  ~~~> Input variables
   REAL(kind=dp), INTENT(IN) :: A(LU_NONZERO)
   INTEGER, INTENT(IN) :: Pivot(NVAR)
!  ~~~> InOut variables
   REAL(kind=dp), INTENT(INOUT) :: b(NVAR)

# 3033

   CALL KppSolve( A, b)


   Nsol = Nsol+ 1

  END SUBROUTINE ros_Solve



!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE Ros2 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha,&
            ros_Gamma,ros_NewF,ros_ELO,ros_Name)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!   - - -  AN L- STABLE METHOD, 2 stages, order 2
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   INTEGER, PARAMETER :: S=2
   INTEGER, INTENT(OUT) ::  ros_S
   REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
   REAL(kind=dp), DIMENSION(S*(S- 1)/2), INTENT(OUT) :: ros_A, ros_C
   REAL(kind=dp), INTENT(OUT) :: ros_ELO
   LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
   CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
   DOUBLE PRECISION g

    g = 1.0_dp +  1.0_dp/SQRT(2.0_dp)

!  ~~~> Name of the method
    ros_Name = 'ROS-2'
!  ~~~> Number of stages
    ros_S = S

!  ~~~> The coefficient matrices A and C are strictly lower triangular.
!     The lower triangular (subdiagonal) elements are stored in row- wise order:
!     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
!     The general mapping formula is:
!         A(i,j) = ros_A( (i- 1)*(i- 2)/2 +  j)
!         C(i,j) = ros_C( (i- 1)*(i- 2)/2 +  j)

    ros_A(1) = (1.0_dp)/g
    ros_C(1) = (- 2.0_dp)/g
!  ~~~> Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
!     or does it re-use the function evaluation from stage i- 1 (ros_NewF(i)=FALSE)
    ros_NewF(1) = .TRUE.
    ros_NewF(2) = .TRUE.
!  ~~~> M_i = Coefficients for new step solution
    ros_M(1)= (3.0_dp)/(2.0_dp*g)
    ros_M(2)= (1.0_dp)/(2.0_dp*g)
!   E_i = Coefficients for error estimator
    ros_E(1) = 1.0_dp/(2.0_dp*g)
    ros_E(2) = 1.0_dp/(2.0_dp*g)
!  ~~~> ros_ELO = estimator of local order -  the minimum between the
!      main and the embedded scheme orders plus one
    ros_ELO = 2.0_dp
!  ~~~> Y_stage_i ~ Y( T +  H*Alpha_i)
    ros_Alpha(1) = 0.0_dp
    ros_Alpha(2) = 1.0_dp
!  ~~~> Gamma_i = \sum_j  gamma_{i,j}
    ros_Gamma(1) = g
    ros_Gamma(2) =- g

 END SUBROUTINE Ros2


!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE Ros3 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha,&
           ros_Gamma,ros_NewF,ros_ELO,ros_Name)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!   - - -  AN L- STABLE METHOD, 3 stages, order 3, 2 function evaluations
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   INTEGER, PARAMETER :: S=3
   INTEGER, INTENT(OUT) ::  ros_S
   REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
   REAL(kind=dp), DIMENSION(S*(S- 1)/2), INTENT(OUT) :: ros_A, ros_C
   REAL(kind=dp), INTENT(OUT) :: ros_ELO
   LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
   CHARACTER(LEN=12), INTENT(OUT) :: ros_Name

!  ~~~> Name of the method
   ros_Name = 'ROS-3'
!  ~~~> Number of stages
   ros_S = S

!  ~~~> The coefficient matrices A and C are strictly lower triangular.
!     The lower triangular (subdiagonal) elements are stored in row- wise order:
!     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
!     The general mapping formula is:
!         A(i,j) = ros_A( (i- 1)*(i- 2)/2 +  j)
!         C(i,j) = ros_C( (i- 1)*(i- 2)/2 +  j)

   ros_A(1)= 1.0_dp
   ros_A(2)= 1.0_dp
   ros_A(3)= 0.0_dp

   ros_C(1) = - 0.10156171083877702091975600115545E+01_dp
   ros_C(2) =  0.40759956452537699824805835358067E+01_dp
   ros_C(3) =  0.92076794298330791242156818474003E+01_dp
!  ~~~> Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
!     or does it re-use the function evaluation from stage i- 1 (ros_NewF(i)=FALSE)
   ros_NewF(1) = .TRUE.
   ros_NewF(2) = .TRUE.
   ros_NewF(3) = .FALSE.
!  ~~~> M_i = Coefficients for new step solution
   ros_M(1) =  0.1E+01_dp
   ros_M(2) =  0.61697947043828245592553615689730E+01_dp
   ros_M(3) = - 0.42772256543218573326238373806514E+00_dp
!   E_i = Coefficients for error estimator
   ros_E(1) =  0.5E+00_dp
   ros_E(2) = - 0.29079558716805469821718236208017E+01_dp
   ros_E(3) =  0.22354069897811569627360909276199E+00_dp
!  ~~~> ros_ELO = estimator of local order -  the minimum between the
!      main and the embedded scheme orders plus 1
   ros_ELO = 3.0_dp
!  ~~~> Y_stage_i ~ Y( T +  H*Alpha_i)
   ros_Alpha(1)= 0.0E+00_dp
   ros_Alpha(2)= 0.43586652150845899941601945119356E+00_dp
   ros_Alpha(3)= 0.43586652150845899941601945119356E+00_dp
!  ~~~> Gamma_i = \sum_j  gamma_{i,j}
   ros_Gamma(1)= 0.43586652150845899941601945119356E+00_dp
   ros_Gamma(2)= 0.24291996454816804366592249683314E+00_dp
   ros_Gamma(3)= 0.21851380027664058511513169485832E+01_dp

  END SUBROUTINE Ros3

!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE Ros4 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha,&
           ros_Gamma,ros_NewF,ros_ELO,ros_Name)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       L- STABLE ROSENBROCK METHOD OF ORDER 4, WITH 4 STAGES
!       L- STABLE EMBEDDED ROSENBROCK METHOD OF ORDER 3
!
!        E. HAIRER AND G. WANNER, SOLVING ORDINARY DIFFERENTIAL
!        EQUATIONS II. STIFF AND DIFFERENTIAL- ALGEBRAIC PROBLEMS.
!        SPRINGER SERIES IN COMPUTATIONAL MATHEMATICS,
!        SPRINGER- VERLAG (1990)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   INTEGER, PARAMETER :: S=4
   INTEGER, INTENT(OUT) ::  ros_S
   REAL(kind=dp), DIMENSION(4), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
   REAL(kind=dp), DIMENSION(6), INTENT(OUT) :: ros_A, ros_C
   REAL(kind=dp), INTENT(OUT) :: ros_ELO
   LOGICAL, DIMENSION(4), INTENT(OUT) :: ros_NewF
   CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
   DOUBLE PRECISION g

!  ~~~> Name of the method
   ros_Name = 'ROS-4'
!  ~~~> Number of stages
   ros_S = S

!  ~~~> The coefficient matrices A and C are strictly lower triangular.
!     The lower triangular (subdiagonal) elements are stored in row- wise order:
!     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
!     The general mapping formula is:
!         A(i,j) = ros_A( (i- 1)*(i- 2)/2 +  j)
!         C(i,j) = ros_C( (i- 1)*(i- 2)/2 +  j)

   ros_A(1) = 0.2000000000000000E+01_dp
   ros_A(2) = 0.1867943637803922E+01_dp
   ros_A(3) = 0.2344449711399156E+00_dp
   ros_A(4) = ros_A(2)
   ros_A(5) = ros_A(3)
   ros_A(6) = 0.0_dp

   ros_C(1) =- 0.7137615036412310E+01_dp
   ros_C(2) = 0.2580708087951457E+01_dp
   ros_C(3) = 0.6515950076447975E+00_dp
   ros_C(4) =- 0.2137148994382534E+01_dp
   ros_C(5) =- 0.3214669691237626E+00_dp
   ros_C(6) =- 0.6949742501781779E+00_dp
!  ~~~> Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
!     or does it re-use the function evaluation from stage i- 1 (ros_NewF(i)=FALSE)
   ros_NewF(1)  = .TRUE.
   ros_NewF(2)  = .TRUE.
   ros_NewF(3)  = .TRUE.
   ros_NewF(4)  = .FALSE.
!  ~~~> M_i = Coefficients for new step solution
   ros_M(1) = 0.2255570073418735E+01_dp
   ros_M(2) = 0.2870493262186792E+00_dp
   ros_M(3) = 0.4353179431840180E+00_dp
   ros_M(4) = 0.1093502252409163E+01_dp
!  ~~~> E_i  = Coefficients for error estimator
   ros_E(1) =- 0.2815431932141155E+00_dp
   ros_E(2) =- 0.7276199124938920E-01_dp
   ros_E(3) =- 0.1082196201495311E+00_dp
   ros_E(4) =- 0.1093502252409163E+01_dp
!  ~~~> ros_ELO  = estimator of local order -  the minimum between the
!      main and the embedded scheme orders plus 1
   ros_ELO  = 4.0_dp
!  ~~~> Y_stage_i ~ Y( T +  H*Alpha_i)
   ros_Alpha(1) = 0.0_dp
   ros_Alpha(2) = 0.1145640000000000E+01_dp
   ros_Alpha(3) = 0.6552168638155900E+00_dp
   ros_Alpha(4) = ros_Alpha(3)
!  ~~~> Gamma_i = \sum_j  gamma_{i,j}
   ros_Gamma(1) = 0.5728200000000000E+00_dp
   ros_Gamma(2) =- 0.1769193891319233E+01_dp
   ros_Gamma(3) = 0.7592633437920482E+00_dp
   ros_Gamma(4) =- 0.1049021087100450E+00_dp

  END SUBROUTINE Ros4

!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE Rodas3 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha,&
            ros_Gamma,ros_NewF,ros_ELO,ros_Name)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!   - - -  A STIFFLY- STABLE METHOD, 4 stages, order 3
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   INTEGER, PARAMETER :: S=4
   INTEGER, INTENT(OUT) ::  ros_S
   REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
   REAL(kind=dp), DIMENSION(S*(S- 1)/2), INTENT(OUT) :: ros_A, ros_C
   REAL(kind=dp), INTENT(OUT) :: ros_ELO
   LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
   CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
   DOUBLE PRECISION g

!  ~~~> Name of the method
   ros_Name = 'RODAS-3'
!  ~~~> Number of stages
   ros_S = S

!  ~~~> The coefficient matrices A and C are strictly lower triangular.
!     The lower triangular (subdiagonal) elements are stored in row- wise order:
!     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
!     The general mapping formula is:
!         A(i,j) = ros_A( (i- 1)*(i- 2)/2 +  j)
!         C(i,j) = ros_C( (i- 1)*(i- 2)/2 +  j)

   ros_A(1) = 0.0E+00_dp
   ros_A(2) = 2.0E+00_dp
   ros_A(3) = 0.0E+00_dp
   ros_A(4) = 2.0E+00_dp
   ros_A(5) = 0.0E+00_dp
   ros_A(6) = 1.0E+00_dp

   ros_C(1) = 4.0E+00_dp
   ros_C(2) = 1.0E+00_dp
   ros_C(3) =- 1.0E+00_dp
   ros_C(4) = 1.0E+00_dp
   ros_C(5) =- 1.0E+00_dp
   ros_C(6) =- (8.0E+00_dp/3.0E+00_dp)

!  ~~~> Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
!     or does it re-use the function evaluation from stage i- 1 (ros_NewF(i)=FALSE)
   ros_NewF(1)  = .TRUE.
   ros_NewF(2)  = .FALSE.
   ros_NewF(3)  = .TRUE.
   ros_NewF(4)  = .TRUE.
!  ~~~> M_i = Coefficients for new step solution
   ros_M(1) = 2.0E+00_dp
   ros_M(2) = 0.0E+00_dp
   ros_M(3) = 1.0E+00_dp
   ros_M(4) = 1.0E+00_dp
!  ~~~> E_i  = Coefficients for error estimator
   ros_E(1) = 0.0E+00_dp
   ros_E(2) = 0.0E+00_dp
   ros_E(3) = 0.0E+00_dp
   ros_E(4) = 1.0E+00_dp
!  ~~~> ros_ELO  = estimator of local order -  the minimum between the
!      main and the embedded scheme orders plus 1
   ros_ELO  = 3.0E+00_dp
!  ~~~> Y_stage_i ~ Y( T +  H*Alpha_i)
   ros_Alpha(1) = 0.0E+00_dp
   ros_Alpha(2) = 0.0E+00_dp
   ros_Alpha(3) = 1.0E+00_dp
   ros_Alpha(4) = 1.0E+00_dp
!  ~~~> Gamma_i = \sum_j  gamma_{i,j}
   ros_Gamma(1) = 0.5E+00_dp
   ros_Gamma(2) = 1.5E+00_dp
   ros_Gamma(3) = 0.0E+00_dp
   ros_Gamma(4) = 0.0E+00_dp

  END SUBROUTINE Rodas3

!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE Rodas4 (ros_S,ros_A,ros_C,ros_M,ros_E,ros_Alpha,&
             ros_Gamma,ros_NewF,ros_ELO,ros_Name)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       STIFFLY- STABLE ROSENBROCK METHOD OF ORDER 4, WITH 6 STAGES
!
!        E. HAIRER AND G. WANNER, SOLVING ORDINARY DIFFERENTIAL
!        EQUATIONS II. STIFF AND DIFFERENTIAL- ALGEBRAIC PROBLEMS.
!        SPRINGER SERIES IN COMPUTATIONAL MATHEMATICS,
!        SPRINGER- VERLAG (1996)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   INTEGER, PARAMETER :: S=6
   INTEGER, INTENT(OUT) ::  ros_S
   REAL(kind=dp), DIMENSION(S), INTENT(OUT) :: ros_M,ros_E,ros_Alpha,ros_Gamma
   REAL(kind=dp), DIMENSION(S*(S- 1)/2), INTENT(OUT) :: ros_A, ros_C
   REAL(kind=dp), INTENT(OUT) :: ros_ELO
   LOGICAL, DIMENSION(S), INTENT(OUT) :: ros_NewF
   CHARACTER(LEN=12), INTENT(OUT) :: ros_Name
   DOUBLE PRECISION g

!  ~~~> Name of the method
    ros_Name = 'RODAS-4'
!  ~~~> Number of stages
    ros_S = 6

!  ~~~> Y_stage_i ~ Y( T +  H*Alpha_i)
    ros_Alpha(1) = 0.000_dp
    ros_Alpha(2) = 0.386_dp
    ros_Alpha(3) = 0.210_dp
    ros_Alpha(4) = 0.630_dp
    ros_Alpha(5) = 1.000_dp
    ros_Alpha(6) = 1.000_dp

!  ~~~> Gamma_i = \sum_j  gamma_{i,j}
    ros_Gamma(1) = 0.2500000000000000E+00_dp
    ros_Gamma(2) =- 0.1043000000000000E+00_dp
    ros_Gamma(3) = 0.1035000000000000E+00_dp
    ros_Gamma(4) =- 0.3620000000000023E-01_dp
    ros_Gamma(5) = 0.0_dp
    ros_Gamma(6) = 0.0_dp

!  ~~~> The coefficient matrices A and C are strictly lower triangular.
!     The lower triangular (subdiagonal) elements are stored in row- wise order:
!     A(2,1) = ros_A(1), A(3,1)=ros_A(2), A(3,2)=ros_A(3), etc.
!     The general mapping formula is:  A(i,j) = ros_A( (i- 1)*(i- 2)/2 +  j)
!                    C(i,j) = ros_C( (i- 1)*(i- 2)/2 +  j)

    ros_A(1) = 0.1544000000000000E+01_dp
    ros_A(2) = 0.9466785280815826E+00_dp
    ros_A(3) = 0.2557011698983284E+00_dp
    ros_A(4) = 0.3314825187068521E+01_dp
    ros_A(5) = 0.2896124015972201E+01_dp
    ros_A(6) = 0.9986419139977817E+00_dp
    ros_A(7) = 0.1221224509226641E+01_dp
    ros_A(8) = 0.6019134481288629E+01_dp
    ros_A(9) = 0.1253708332932087E+02_dp
    ros_A(10) =- 0.6878860361058950E+00_dp
    ros_A(11) = ros_A(7)
    ros_A(12) = ros_A(8)
    ros_A(13) = ros_A(9)
    ros_A(14) = ros_A(10)
    ros_A(15) = 1.0E+00_dp

    ros_C(1) =- 0.5668800000000000E+01_dp
    ros_C(2) =- 0.2430093356833875E+01_dp
    ros_C(3) =- 0.2063599157091915E+00_dp
    ros_C(4) =- 0.1073529058151375E+00_dp
    ros_C(5) =- 0.9594562251023355E+01_dp
    ros_C(6) =- 0.2047028614809616E+02_dp
    ros_C(7) = 0.7496443313967647E+01_dp
    ros_C(8) =- 0.1024680431464352E+02_dp
    ros_C(9) =- 0.3399990352819905E+02_dp
    ros_C(10) = 0.1170890893206160E+02_dp
    ros_C(11) = 0.8083246795921522E+01_dp
    ros_C(12) =- 0.7981132988064893E+01_dp
    ros_C(13) =- 0.3152159432874371E+02_dp
    ros_C(14) = 0.1631930543123136E+02_dp
    ros_C(15) =- 0.6058818238834054E+01_dp

!  ~~~> M_i = Coefficients for new step solution
    ros_M(1) = ros_A(7)
    ros_M(2) = ros_A(8)
    ros_M(3) = ros_A(9)
    ros_M(4) = ros_A(10)
    ros_M(5) = 1.0E+00_dp
    ros_M(6) = 1.0E+00_dp

!  ~~~> E_i  = Coefficients for error estimator
    ros_E(1) = 0.0E+00_dp
    ros_E(2) = 0.0E+00_dp
    ros_E(3) = 0.0E+00_dp
    ros_E(4) = 0.0E+00_dp
    ros_E(5) = 0.0E+00_dp
    ros_E(6) = 1.0E+00_dp

!  ~~~> Does the stage i require a new function evaluation (ros_NewF(i)=TRUE)
!     or does it re-use the function evaluation from stage i- 1 (ros_NewF(i)=FALSE)
    ros_NewF(1) = .TRUE.
    ros_NewF(2) = .TRUE.
    ros_NewF(3) = .TRUE.
    ros_NewF(4) = .TRUE.
    ros_NewF(5) = .TRUE.
    ros_NewF(6) = .TRUE.

!  ~~~> ros_ELO  = estimator of local order -  the minimum between the
!          main and the embedded scheme orders plus 1
    ros_ELO = 4.0_dp

  END SUBROUTINE Rodas4

!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!     End of the set of internal Rosenbrock subroutines
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
END SUBROUTINE Rosenbrock
 
SUBROUTINE FunTemplate( T, Y, Ydot)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Template for the ODE function call.
!    Updates the rate coefficients (and possibly the fixed species) at each call
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  ~~~> Input variables
   REAL(kind=dp) :: T, Y(NVAR)
!  ~~~> Output variables
   REAL(kind=dp) :: Ydot(NVAR)
!  ~~~> Local variables
   REAL(kind=dp) :: Told

   Told = TIME
   TIME = T
!     CALL Update_SUN()
!     CALL Update_RCONST()
   CALL Fun( Y, FIX, RCONST, Ydot)
   TIME = Told

   Nfun = Nfun+ 1

END SUBROUTINE FunTemplate
 
SUBROUTINE JacTemplate( T, Y, Jcb)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!    Template for the ODE Jacobian call.
!    Updates the rate coefficients (and possibly the fixed species) at each call
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  ~~~> Input variables
    REAL(kind=dp) :: T, Y(NVAR)
!  ~~~> Output variables
# 3469

    REAL(kind=dp) :: Jcb(LU_NONZERO)

!  ~~~> Local variables
    REAL(kind=dp) :: Told
# 3476


    Told = TIME
    TIME = T
!      CALL Update_SUN()
!      CALL Update_RCONST()
# 3492

    CALL Jac_SP( Y, FIX, RCONST, Jcb)

    TIME = Told

    Njac = Njac+ 1

END SUBROUTINE JacTemplate
 
  SUBROUTINE Update_SUN()
! USE messy_scav_i_kpp_Parameters
! USE messy_scav_i_kpp_Global


    REAL(kind=dp) :: SunRise, SunSet
    REAL(kind=dp) :: Thour, Tlocal, Ttmp 
!  PI -  Value of pi
    REAL(kind=dp), PARAMETER :: PI = 3.14159265358979d0
    
    SunRise = 4.5_dp 
    SunSet  = 19.5_dp 
    Thour = TIME/3600.0_dp 
    Tlocal = Thour -  (INT(Thour)/24)*24

    IF ((Tlocal>=SunRise).AND.(Tlocal<=SunSet))THEN
       Ttmp = (2.0*Tlocal- SunRise-SunSet)/(SunSet- SunRise)
       IF (Ttmp.GT.0) THEN
          Ttmp =  Ttmp*Ttmp
       ELSE
          Ttmp = - Ttmp*Ttmp
       END IF
       SUN =(1.0_dp +  COS(PI*Ttmp))/2.0_dp 
    ELSE
       SUN = 0.0_dp 
    END IF

 END SUBROUTINE Update_SUN
 
SUBROUTINE error_output(C,ierr,PE)

!  must be set in module header: USE messy_main_tools,      ONLY: str


  INTEGER, INTENT(IN) :: ierr
  INTEGER, INTENT(IN) :: PE
  REAL(dp), DIMENSION(:),INTENT(IN) :: C

  INTEGER,SAVE :: NUM =0
  INTEGER :: iou
  INTEGER :: i

  CHARACTER(LEN=250)  :: filename
  CHARACTER(LEN=1000) :: strnum
  CHARACTER(LEN=1000) :: strPE
  CHARACTER(256)      :: info

  LOGICAL             :: opened
  IF (ierr >= 0) RETURN

  NUM = NUM + 1

  strnum=str(NUM)
  strPE=str(PE)

  WRITE(filename,*) 'mecca_PE'//TRIM(STRPE)//'_'//TRIM(STRNUM)//'.txt'

  iou = 0
  DO i=100,200
     INQUIRE(unit=i,opened=opened)
     IF (.NOT.opened) THEN
        iou = i
        EXIT
     END IF
  END DO

  IF (iou==0) THEN
     WRITE(info,'(a,i2.2,a,i2.2,a)') &
          'No unit in range < 100 : 200 > free.'
     RETURN
  ENDIF

  OPEN(IOU,FILE =TRIM(ADJUSTL(filename))&
       ,STATUS='NEW',ACTION= 'WRITE')

!  ERROR STATUS
  WRITE(IOU,*) 'KPP ERRORSTATUS IERR:'
  WRITE(IOU,*)IERR

!  SPECIES NAME
  WRITE(IOU,*) 'SELECTED MECHANISM'
  WRITE(IOU,*)WANTED
  WRITE(IOU,*)

  WRITE(IOU,*) 'NUMBER OF SPECIES:'
  WRITE(IOU,*)NSPEC
  WRITE(IOU,*)
  WRITE(IOU,*)  'NAMES OF SPECIES:'
  DO i=1,NSPEC
  WRITE(IOU,*) SPC_NAMES(i)
  ENDDO
  WRITE(IOU,*)

!  CONCENTRATIONS
  WRITE(IOU,*) 'concentrations (molec/cm^3(air) before KPP'
  DO i=1,NSPEC
     WRITE(IOU,*)C(i)
  ENDDO
  WRITE(IOU,*)

!  rates
  WRITE(IOU,*) 'rate contants'
  DO i=1,NREACT
     WRITE(IOU,*)RCONST(i)
  ENDDO
  WRITE(IOU,*)
  CLOSE(IOU)

END SUBROUTINE error_output
 
  SUBROUTINE KppDecomp( JVS,IER)                                     
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!        Sparse LU factorization
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! Loop expansion generated by kp4
                                                                      
    INTEGER  :: IER                                                   
    REAL(kind=dp):: JVS(LU_NONZERO),W(NVAR),a             
    INTEGER  :: k,kk,j,jj                                          
                                                                      
    a = 0.                                                            
    IER = 0                                                           
                                                                      
!   k = 1     Nothing to do    LU_CROW[k] > LU_DIAG[k]-1   (1 0)
!   k = 2     Nothing to do    LU_CROW[k] > LU_DIAG[k]-1   (2 1)
!   k = 3
    W(2)= JVS(4)
    W(3)= JVS(5)
    a = - W(2)/ JVS(2)
    W(2)= -a
      W(3)= W(3)+ a *JVS(3)
    JVS(4)= W(2)
    JVS(5)= W(3)
    return                                                            
                                                                      
  End SUBROUTINE KppDecomp                                            
 
SUBROUTINE kpp_integrate (time_step_len,Conc,ierrf,xNacc,xNrej,istatus,l_debug,PE) 
                                                                    
  IMPLICIT NONE                                                     
                                                                    
  REAL(dp),INTENT(IN)                   :: time_step_len           
  REAL(dp),INTENT(INOUT),dimension(:,:) :: Conc                    
  INTEGER, INTENT(OUT),OPTIONAL        :: ierrf(:)                
  INTEGER, INTENT(OUT),OPTIONAL        :: xNacc(:)                
  INTEGER, INTENT(OUT),OPTIONAL        :: xNrej(:)                
  INTEGER, INTENT(INOUT),OPTIONAL      :: istatus(:)              
  INTEGER, INTENT(IN),OPTIONAL         :: PE                      
  LOGICAL, INTENT(IN),OPTIONAL         :: l_debug                 
                                                                    
  INTEGER                                :: k   ! loop variable
  REAL(dp)                               :: dt                      
  integer,dimension(20)                 :: istatus_u               
  integer                                :: ierr_u                  
# 3662

                                                                    
! ierrf = 0 ; CALL check_kpp_input(Conc,PE) ; RETURN
                                                                    
  if (present (istatus)) istatus = 0                              
                                                                    
# 3683

                                                                    
# 3688

                                                                    
  DO k=1,VL_glo,VL_DIM                                              
    is = k                                                          
    ie = min(k+VL_DIM-1,VL_glo)                                     
    vl = ie-is+1                                                    
                                                                    
# 3700

                                                                    

                                                                    
    C(:) = Conc(is,:)                                             
    CALL update_rconst                                              
                                                                    
    dt = time_step_len                                              
                                                                    
! integrate from t=0 to t=dt
    CALL integrate(0._dp,dt,icntrl,rcntrl,istatus_u = istatus_u,ierr_u=ierr_u)
                                                                    
                                                                    
   IF (PRESENT(l_debug) .AND. PRESENT(PE)) THEN                       
      IF (l_debug) CALL error_output(Conc(is,:),ierr_u,PE)           
   ENDIF                                                              
    Conc(is,:) = C(:)                                                 

                                                                    
! Return Diagnostic Information
                                                                    

    if(Present(ierrf))    ierrf(is) = IERR_U                      
    if(Present(xNacc))    xNacc(is) = istatus_u(4)                
    if(Present(xNrej))    xNrej(is) = istatus_u(5)                
# 3729

                                                                    
    if (present (istatus)) then                                   
      istatus(1:8) = istatus(1:8) + istatus_u(1:8)                 
    end if                                                          
                                                                    
                                                                    
# 3738

                                                                    
  END DO                                                            
 
                                                                    
# 3747

                                                                    
                                                                    
! Deallocate input arrays
                                                                    
  if (allocated(TEMP))   deallocate(TEMP)   
  if (allocated(mcexp))   deallocate(mcexp)   
  if (allocated(cair))   deallocate(cair)   
  if (allocated(press))   deallocate(press)   
  if (allocated(cv_l))   deallocate(cv_l)   
  if (allocated(lwc))   deallocate(lwc)   
  if (allocated(k_exf))   deallocate(k_exf)   
  if (allocated(k_exb))   deallocate(k_exb)   
  if (allocated(k_exf_N2O5))   deallocate(k_exf_N2O5)   
  if (allocated(k_exf_ClNO3))   deallocate(k_exf_ClNO3)   
  if (allocated(k_exf_BrNO3))   deallocate(k_exf_BrNO3)   
  if (allocated(jx))   deallocate(jx)   
# 3767

                                                                    
  data_loaded = .false.                                             
                                                                    
  return                                                            
END SUBROUTINE kpp_integrate                                        
 
  SUBROUTINE fill_TEMP(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(TEMP)) & 
       allocate(TEMP(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    TEMP = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_TEMP
 
  SUBROUTINE fill_mcexp(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:,:) :: array 
 
    status = 0 
    if (.not. allocated(mcexp)) & 
        allocate(mcexp(size(array,1),MAX_MCEXP)) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    mcexp = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_mcexp
 
  SUBROUTINE fill_cair(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(cair)) & 
       allocate(cair(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    cair = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_cair
 
  SUBROUTINE fill_press(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(press)) & 
       allocate(press(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    press = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_press
 
  SUBROUTINE fill_cv_l(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(cv_l)) & 
       allocate(cv_l(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    cv_l = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_cv_l
 
  SUBROUTINE fill_lwc(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(lwc)) & 
       allocate(lwc(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    lwc = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_lwc
 
  SUBROUTINE fill_k_exf(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:,:) :: array 
 
    status = 0 
    if (.not. allocated(k_exf)) & 
        allocate(k_exf(size(array,1),NSPEC)) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    k_exf = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_k_exf
 
  SUBROUTINE fill_k_exb(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:,:) :: array 
 
    status = 0 
    if (.not. allocated(k_exb)) & 
        allocate(k_exb(size(array,1),NSPEC)) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    k_exb = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_k_exb
 
  SUBROUTINE fill_k_exf_N2O5(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(k_exf_N2O5)) & 
       allocate(k_exf_N2O5(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    k_exf_N2O5 = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_k_exf_N2O5
 
  SUBROUTINE fill_k_exf_ClNO3(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(k_exf_ClNO3)) & 
       allocate(k_exf_ClNO3(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    k_exf_ClNO3 = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_k_exf_ClNO3
 
  SUBROUTINE fill_k_exf_BrNO3(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:) :: array 
 
    status = 0
    if (.not. allocated(k_exf_BrNO3)) & 
       allocate(k_exf_BrNO3(size(array))) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    k_exf_BrNO3 = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_k_exf_BrNO3
 
  SUBROUTINE fill_jx(status,array) 
 
    integer,intent(OUT)               :: status 
    real (dp),intent(IN),dimension(:,:) :: array 
 
    status = 0 
    if (.not. allocated(jx)) & 
        allocate(jx(size(array,1),IP_MAX)) 
 
    IF (data_loaded .AND. (VL_glo /= size(array,1))) THEN 
       status = 1 
       RETURN 
    END IF 
 
    VL_glo = size(array,1) 
    jx = array 
    data_loaded = .TRUE. 
 
    RETURN
 
  END   SUBROUTINE fill_jx

end module messy_scav_i_kpp
 
